import { CommonModule } from '@angular/common';
import { Injectable, EventEmitter, Component, Renderer2, ViewChild, Input, Output, Directive, Host, ElementRef, ChangeDetectionStrategy, ChangeDetectorRef, Optional, Attribute, Pipe, HostListener, NgModule } from '@angular/core';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatSlider, MAT_SLIDER_VALUE_ACCESSOR, MatSliderModule } from '@angular/material/slider';
import { FocusMonitor } from '@angular/cdk/a11y';
import { Directionality } from '@angular/cdk/bidi';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@angular/cdk/a11y';
import * as ɵngcc3 from '@angular/cdk/bidi';
import * as ɵngcc4 from '@angular/material/button';
import * as ɵngcc5 from '@angular/material/icon';
import * as ɵngcc6 from '@angular/material/slider';

const _c0 = ["player"];
const _c1 = ["video"];
function MatVideoComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 7);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r1.getOverlayClass("visible", "hidden"));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.title, " ");
} }
function MatVideoComponent_div_8_mat_frame_by_frame_control_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "mat-frame-by-frame-control", 21);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    const _r2 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵproperty("video", _r2)("fps", ctx_r4.fps);
} }
function MatVideoComponent_div_8_mat_quality_control_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "mat-quality-control", 16);
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r2 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵproperty("video", _r2);
} }
function MatVideoComponent_div_8_mat_download_button_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "mat-download-button", 22);
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);
    const _r2 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵproperty("title", ctx_r6.title)("video", _r2);
} }
function MatVideoComponent_div_8_mat_fullscreen_button_12_Template(rf, ctx) { if (rf & 1) {
    const _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "mat-fullscreen-button", 23);
    ɵngcc0.ɵɵlistener("fullscreenChanged", function MatVideoComponent_div_8_mat_fullscreen_button_12_Template_mat_fullscreen_button_fullscreenChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); const ctx_r8 = ɵngcc0.ɵɵnextContext(2); return ctx_r8.isFullscreen = $event; });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    const _r0 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵproperty("player", _r0)("keyboard", ctx_r7.keyboard);
} }
function MatVideoComponent_div_8_Template(rf, ctx) { if (rf & 1) {
    const _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵelementStart(1, "div", 9);
    ɵngcc0.ɵɵelement(2, "mat-seek-progress-control", 10);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "div", 11);
    ɵngcc0.ɵɵelementStart(4, "div", 12);
    ɵngcc0.ɵɵelementStart(5, "mat-play-button", 13);
    ɵngcc0.ɵɵlistener("playChanged", function MatVideoComponent_div_8_Template_mat_play_button_playChanged_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); const ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.playing = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(6, MatVideoComponent_div_8_mat_frame_by_frame_control_6_Template, 1, 2, "mat-frame-by-frame-control", 14);
    ɵngcc0.ɵɵelementStart(7, "mat-volume-control", 15);
    ɵngcc0.ɵɵlistener("mutedChanged", function MatVideoComponent_div_8_Template_mat_volume_control_mutedChanged_7_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); const ctx_r12 = ɵngcc0.ɵɵnextContext(); ctx_r12.muted = $event; return ctx_r12.mutedChange.emit(ctx_r12.muted); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(8, "mat-time-control", 16);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(9, "div", 17);
    ɵngcc0.ɵɵtemplate(10, MatVideoComponent_div_8_mat_quality_control_10_Template, 1, 1, "mat-quality-control", 18);
    ɵngcc0.ɵɵtemplate(11, MatVideoComponent_div_8_mat_download_button_11_Template, 1, 2, "mat-download-button", 19);
    ɵngcc0.ɵɵtemplate(12, MatVideoComponent_div_8_mat_fullscreen_button_12_Template, 1, 2, "mat-fullscreen-button", 20);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    const _r2 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r3.getOverlayClass("visible", "hidden"));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("color", ctx_r3.color)("video", _r2);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("video", _r2)("keyboard", ctx_r3.keyboard);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.showFrameByFrame);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("muted", ctx_r3.muted)("color", ctx_r3.color)("video", _r2)("keyboard", ctx_r3.keyboard);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("video", _r2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.quality);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.download);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.fullscreen);
} }
const _c2 = [[["source"]], [["track"]]];
const _c3 = ["source", "track"];
function MatFullscreenButtonComponent_mat_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "fullscreen");
    ɵngcc0.ɵɵelementEnd();
} }
function MatFullscreenButtonComponent_mat_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "fullscreen_exit");
    ɵngcc0.ɵɵelementEnd();
} }
function MatPlayButtonComponent_mat_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "play_arrow");
    ɵngcc0.ɵɵelementEnd();
} }
function MatPlayButtonComponent_mat_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "pause");
    ɵngcc0.ɵɵelementEnd();
} }
function MatQualityControlComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", ctx_r0.video.videoHeight, "p");
} }
function MatVideoSpinnerComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div");
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMap(ctx_r0.spinner);
} }
function MatVolumeControlComponent_mat_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "volume_off");
    ɵngcc0.ɵɵelementEnd();
} }
function MatVolumeControlComponent_mat_icon_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "volume_mute");
    ɵngcc0.ɵɵelementEnd();
} }
function MatVolumeControlComponent_mat_icon_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "volume_down");
    ɵngcc0.ɵɵelementEnd();
} }
function MatVolumeControlComponent_mat_icon_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "volume_up");
    ɵngcc0.ɵɵelementEnd();
} }
class EventService {
    constructor() { }
    /**
     * @param {?} renderer
     * @param {?} events
     * @return {?}
     */
    addEvents(renderer, events) {
        for (const event of events) {
            event.dispose = renderer.listen(event.element, event.name, (/**
             * @param {?} newEvent
             * @return {?}
             */
            newEvent => event.callback(newEvent)));
        }
    }
    /**
     * @param {?} events
     * @return {?}
     */
    removeEvents(events) {
        for (const event of events) {
            if (event.dispose) {
                event.dispose();
            }
        }
    }
}
EventService.ɵfac = function EventService_Factory(t) { return new (t || EventService)(); };
EventService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: EventService, factory: EventService.ɵfac });
/** @nocollapse */
EventService.ctorParameters = () => [];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EventService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MatVideoComponent {
    /**
     * @param {?} renderer
     * @param {?} evt
     */
    constructor(renderer, evt) {
        this.renderer = renderer;
        this.evt = evt;
        this.src = null;
        this.title = null;
        this.autoplay = false;
        this.preload = true;
        this.loop = false;
        this.quality = true;
        this.fullscreen = true;
        this.playsinline = false;
        this.showFrameByFrame = false;
        this.fps = 29.97;
        this.download = false;
        this.color = "primary";
        this.spinner = "spin";
        this.poster = null;
        this.keyboard = true;
        this.overlay = null;
        this.muted = false;
        this.mutedChange = new EventEmitter();
        this.timeChange = new EventEmitter();
        this.playing = false;
        this.isFullscreen = false;
        this.videoLoaded = false;
        this.isMouseMoving = false;
        this.isMouseMovingTimeout = 2000;
    }
    /**
     * @return {?}
     */
    get time() {
        return this.getVideoTag().currentTime;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set time(val) {
        /** @type {?} */
        const video = this.getVideoTag();
        if (video && val) {
            if (val > video.duration) {
                val = video.duration;
            }
            if (val < 0) {
                val = 0;
            }
            if (val !== video.currentTime) {
                video.currentTime = val;
            }
            if (this.lastTime !== video.currentTime) {
                setTimeout((/**
                 * @return {?}
                 */
                () => this.timeChange.emit(video.currentTime)), 0);
                this.lastTime = video.currentTime;
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.events = [
            {
                element: this.video.nativeElement,
                name: "loadstart",
                callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                event => (this.videoLoaded = false)),
                dispose: null
            },
            {
                element: this.video.nativeElement,
                name: "loadedmetadata",
                callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                event => this.evLoadedMetadata(event)),
                dispose: null
            },
            {
                element: this.video.nativeElement,
                name: "error",
                callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                event => console.error("Unhandled Video Error", event)),
                dispose: null
            },
            {
                element: this.video.nativeElement,
                name: "contextmenu",
                callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                event => event.preventDefault()),
                dispose: null
            },
            {
                element: this.video.nativeElement,
                name: "timeupdate",
                callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                event => this.evTimeUpdate(event)),
                dispose: null
            },
            {
                element: this.player.nativeElement,
                name: "mousemove",
                callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                event => this.evMouseMove(event)),
                dispose: null
            }
        ];
        this.video.nativeElement.onloadeddata = (/**
         * @return {?}
         */
        () => (this.videoLoaded = true));
        this.evt.addEvents(this.renderer, this.events);
        this.setVideoSrc(this.src);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.src) {
            this.setVideoSrc(this.src);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.video.nativeElement.onloadeddata = null;
        this.evt.removeEvents(this.events);
    }
    /**
     * @return {?}
     */
    load() {
        if (this.video && this.video.nativeElement) {
            this.video.nativeElement.load();
        }
    }
    /**
     * @return {?}
     */
    getVideoTag() {
        return this.video && this.video.nativeElement ? ((/** @type {?} */ (this.video.nativeElement))) : null;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    evLoadedMetadata(event) {
        this.videoWidth = this.video.nativeElement.videoWidth;
        this.videoHeight = this.video.nativeElement.videoHeight;
        this.videoLoaded = true;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    evMouseMove(event) {
        this.isMouseMoving = true;
        clearTimeout(this.isMouseMovingTimer);
        this.isMouseMovingTimer = setTimeout((/**
         * @return {?}
         */
        () => {
            this.isMouseMoving = false;
        }), this.isMouseMovingTimeout);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    evTimeUpdate(event) {
        this.time = this.getVideoTag().currentTime;
    }
    /**
     * @param {?} activeClass
     * @param {?} inactiveClass
     * @return {?}
     */
    getOverlayClass(activeClass, inactiveClass) {
        if (this.overlay === null) {
            return !this.playing || this.isMouseMoving ? activeClass : inactiveClass;
        }
        else {
            return this.overlay ? activeClass : inactiveClass;
        }
    }
    /**
     * @private
     * @param {?} src
     * @return {?}
     */
    setVideoSrc(src) {
        if (this.srcObjectURL) {
            URL.revokeObjectURL(this.srcObjectURL);
            this.srcObjectURL = null;
        }
        if (!this.video || !this.video.nativeElement) {
            return;
        }
        if (!src) {
            this.video.nativeElement.src = null;
            if ("srcObject" in HTMLVideoElement.prototype) {
                this.video.nativeElement.srcObject = new MediaStream();
            }
        }
        else if (typeof src === "string") {
            this.video.nativeElement.src = src;
        }
        else if ("srcObject" in HTMLVideoElement.prototype) {
            this.video.nativeElement.srcObject = src;
        }
        else {
            this.srcObjectURL = URL.createObjectURL(src);
            this.video.nativeElement.src = this.srcObjectURL;
        }
        this.video.nativeElement.muted = this.muted;
    }
}
MatVideoComponent.ɵfac = function MatVideoComponent_Factory(t) { return new (t || MatVideoComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(EventService)); };
MatVideoComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatVideoComponent, selectors: [["mat-video"]], viewQuery: function MatVideoComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
        ɵngcc0.ɵɵviewQuery(_c1, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.player = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.video = _t.first);
    } }, inputs: { src: "src", title: "title", autoplay: "autoplay", preload: "preload", loop: "loop", quality: "quality", fullscreen: "fullscreen", playsinline: "playsinline", showFrameByFrame: "showFrameByFrame", fps: "fps", download: "download", color: "color", spinner: "spinner", poster: "poster", keyboard: "keyboard", overlay: "overlay", muted: "muted", time: "time" }, outputs: { mutedChange: "mutedChange", timeChange: "timeChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c3, decls: 10, vars: 10, consts: [[1, "videoplayer", 3, "ngClass"], ["player", ""], ["class", "header", 3, "ngClass", 4, "ngIf"], [1, "video", 3, "preload"], ["video", ""], ["class", "controls", 3, "ngClass", 4, "ngIf"], [3, "spinner", "video"], [1, "header", 3, "ngClass"], [1, "controls", 3, "ngClass"], [1, "progress"], [3, "color", "video"], [1, "menu"], [1, "left"], [3, "video", "keyboard", "playChanged"], [3, "video", "fps", 4, "ngIf"], [3, "muted", "color", "video", "keyboard", "mutedChanged"], [3, "video"], [1, "right"], [3, "video", 4, "ngIf"], [3, "title", "video", 4, "ngIf"], [3, "player", "keyboard", "fullscreenChanged", 4, "ngIf"], [3, "video", "fps"], [3, "title", "video"], [3, "player", "keyboard", "fullscreenChanged"]], template: function MatVideoComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c2);
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵtemplate(2, MatVideoComponent_div_2_Template, 2, 2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "video", 3, 4);
        ɵngcc0.ɵɵprojection(5);
        ɵngcc0.ɵɵprojection(6, 1);
        ɵngcc0.ɵɵtext(7, " This browser does not support HTML5 video. ");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(8, MatVideoComponent_div_8_Template, 13, 14, "div", 5);
        ɵngcc0.ɵɵelement(9, "mat-video-spinner", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r2 = ɵngcc0.ɵɵreference(4);
        ɵngcc0.ɵɵproperty("ngClass", ctx.getOverlayClass("show-mouse", "hide-mouse"));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.title);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("preload", ctx.preload ? "auto" : "metadata");
        ɵngcc0.ɵɵattribute("autoplay", ctx.autoplay ? true : null)("poster", ctx.poster ? ctx.poster : null, ɵngcc0.ɵɵsanitizeUrl)("loop", ctx.loop ? ctx.loop : null)("playsinline", ctx.playsinline ? true : null);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.videoLoaded);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("spinner", ctx.spinner)("video", _r2);
    } }, directives: function () { return [ɵngcc1.NgClass, ɵngcc1.NgIf, MatVideoSpinnerComponent,
        MatSeekProgressControlComponent,
        MatPlayButtonComponent,
        MatVolumeControlComponent,
        MatTimeControlComponent,
        MatFrameByFrameControlComponent,
        MatQualityControlComponent,
        MatDownloadButtonComponent,
        MatFullscreenButtonComponent]; }, styles: [".videoplayer[_ngcontent-%COMP%]{font-family:Roboto,\"Helvetica Neue\",sans-serif;background-color:#000;position:relative;width:100%;height:100%}.header[_ngcontent-%COMP%]{color:#fff;display:flex;justify-content:center;align-items:center;position:absolute;left:0;top:0;padding:14px 0;width:100%;z-index:1;background-image:linear-gradient(to top,rgba(0,0,0,0),rgba(0,0,0,.65))}.video[_ngcontent-%COMP%]{display:block;width:100%;height:100%;z-index:0}.controls[_ngcontent-%COMP%]{color:#fff;position:absolute;left:0;bottom:0;width:100%;z-index:1;background-image:linear-gradient(to bottom,rgba(0,0,0,0),rgba(0,0,0,.65))}.controls[_ngcontent-%COMP%]   .progress[_ngcontent-%COMP%]{height:26px}.controls[_ngcontent-%COMP%]   .menu[_ngcontent-%COMP%]{display:flex;align-items:center;flex-direction:row;justify-content:space-between;height:48px}.controls[_ngcontent-%COMP%]   .menu[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]{justify-content:flex-start}.controls[_ngcontent-%COMP%]   .menu[_ngcontent-%COMP%]   .right[_ngcontent-%COMP%]{justify-content:flex-end}.visible[_ngcontent-%COMP%]{visibility:visible;opacity:1;transition:opacity .5s linear}.hidden[_ngcontent-%COMP%]{visibility:hidden;opacity:0;transition:visibility .5s,opacity .5s linear}.show-mouse[_ngcontent-%COMP%]{cursor:default}.hide-mouse[_ngcontent-%COMP%]{cursor:none}", "@font-face{font-family:\"Material Icons\";font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/materialicons/v36/flUhRq6tzZclQEJ-Vdg-IuiaDsNc.woff2) format(\"woff2\")} .material-icons{font-family:\"Material Icons\";font-weight:400;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;font-feature-settings:\"liga\";-webkit-font-feature-settings:\"liga\";-webkit-font-smoothing:antialiased}"] });
/** @nocollapse */
MatVideoComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: EventService }
];
MatVideoComponent.propDecorators = {
    player: [{ type: ViewChild, args: ["player", { static: false },] }],
    video: [{ type: ViewChild, args: ["video", { static: false },] }],
    src: [{ type: Input }],
    title: [{ type: Input }],
    autoplay: [{ type: Input }],
    preload: [{ type: Input }],
    loop: [{ type: Input }],
    quality: [{ type: Input }],
    fullscreen: [{ type: Input }],
    playsinline: [{ type: Input }],
    showFrameByFrame: [{ type: Input }],
    fps: [{ type: Input }],
    download: [{ type: Input }],
    color: [{ type: Input }],
    spinner: [{ type: Input }],
    poster: [{ type: Input }],
    keyboard: [{ type: Input }],
    overlay: [{ type: Input }],
    muted: [{ type: Input }],
    mutedChange: [{ type: Output }],
    timeChange: [{ type: Output }],
    time: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatVideoComponent, [{
        type: Component,
        args: [{
                selector: "mat-video",
                template: "<div #player class=\"videoplayer\" [ngClass]=\"getOverlayClass('show-mouse', 'hide-mouse')\">\n  <div class=\"header\" *ngIf=\"title\" [ngClass]=\"getOverlayClass('visible', 'hidden')\">\n    {{ title }}\n  </div>\n\n  <video\n    #video\n    class=\"video\"\n    [attr.autoplay]=\"autoplay ? true : null\"\n    [preload]=\"preload ? 'auto' : 'metadata'\"\n    [attr.poster]=\"poster ? poster : null\"\n    [attr.loop]=\"loop ? loop : null\"\n    [attr.playsinline]=\"playsinline ? true : null\"\n  >\n    <ng-content select=\"source\"></ng-content>\n    <ng-content select=\"track\"></ng-content>\n    This browser does not support HTML5 video.\n  </video>\n\n  <div class=\"controls\" *ngIf=\"videoLoaded\" [ngClass]=\"getOverlayClass('visible', 'hidden')\">\n    <div class=\"progress\">\n      <mat-seek-progress-control [color]=\"color\" [video]=\"video\"></mat-seek-progress-control>\n    </div>\n\n    <div class=\"menu\">\n      <div class=\"left\">\n        <mat-play-button (playChanged)=\"playing = $event\" [video]=\"video\" [keyboard]=\"keyboard\"> </mat-play-button>\n\n        <mat-frame-by-frame-control *ngIf=\"showFrameByFrame\" [video]=\"video\" [fps]=\"fps\"></mat-frame-by-frame-control>\n\n        <mat-volume-control\n          [muted]=\"muted\"\n          (mutedChanged)=\"muted = $event; mutedChange.emit(muted)\"\n          [color]=\"color\"\n          [video]=\"video\"\n          [keyboard]=\"keyboard\"\n        >\n        </mat-volume-control>\n\n        <mat-time-control [video]=\"video\"></mat-time-control>\n      </div>\n\n      <div class=\"right\">\n        <mat-quality-control *ngIf=\"quality\" [video]=\"video\"></mat-quality-control>\n\n        <mat-download-button *ngIf=\"download\" [title]=\"title\" [video]=\"video\"></mat-download-button>\n\n        <mat-fullscreen-button\n          *ngIf=\"fullscreen\"\n          (fullscreenChanged)=\"isFullscreen = $event\"\n          [player]=\"player\"\n          [keyboard]=\"keyboard\"\n        ></mat-fullscreen-button>\n      </div>\n    </div>\n  </div>\n\n  <mat-video-spinner [spinner]=\"spinner\" [video]=\"video\"></mat-video-spinner>\n</div>\n",
                styles: [".videoplayer{font-family:Roboto,\"Helvetica Neue\",sans-serif;background-color:#000;position:relative;width:100%;height:100%}.header{color:#fff;display:flex;justify-content:center;align-items:center;position:absolute;left:0;top:0;padding:14px 0;width:100%;z-index:1;background-image:linear-gradient(to top,rgba(0,0,0,0),rgba(0,0,0,.65))}.video{display:block;width:100%;height:100%;z-index:0}.controls{color:#fff;position:absolute;left:0;bottom:0;width:100%;z-index:1;background-image:linear-gradient(to bottom,rgba(0,0,0,0),rgba(0,0,0,.65))}.controls .progress{height:26px}.controls .menu{display:flex;align-items:center;flex-direction:row;justify-content:space-between;height:48px}.controls .menu .left{justify-content:flex-start}.controls .menu .right{justify-content:flex-end}.visible{visibility:visible;opacity:1;transition:opacity .5s linear}.hidden{visibility:hidden;opacity:0;transition:visibility .5s,opacity .5s linear}.show-mouse{cursor:default}.hide-mouse{cursor:none}", "@font-face{font-family:\"Material Icons\";font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/materialicons/v36/flUhRq6tzZclQEJ-Vdg-IuiaDsNc.woff2) format(\"woff2\")}::ng-deep.material-icons{font-family:\"Material Icons\";font-weight:400;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;font-feature-settings:\"liga\";-webkit-font-feature-settings:\"liga\";-webkit-font-smoothing:antialiased}"]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: EventService }]; }, { src: [{
            type: Input
        }], title: [{
            type: Input
        }], autoplay: [{
            type: Input
        }], preload: [{
            type: Input
        }], loop: [{
            type: Input
        }], quality: [{
            type: Input
        }], fullscreen: [{
            type: Input
        }], playsinline: [{
            type: Input
        }], showFrameByFrame: [{
            type: Input
        }], fps: [{
            type: Input
        }], download: [{
            type: Input
        }], color: [{
            type: Input
        }], spinner: [{
            type: Input
        }], poster: [{
            type: Input
        }], keyboard: [{
            type: Input
        }], overlay: [{
            type: Input
        }], muted: [{
            type: Input
        }], mutedChange: [{
            type: Output
        }], timeChange: [{
            type: Output
        }], time: [{
            type: Input
        }], player: [{
            type: ViewChild,
            args: ["player", { static: false }]
        }], video: [{
            type: ViewChild,
            args: ["video", { static: false }]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MatVideoSourceDirective {
    /**
     * @param {?} matVideoComponent
     * @param {?} el
     */
    constructor(matVideoComponent, el) {
        this.matVideoComponent = matVideoComponent;
        this.el = el;
        this.src = null;
        this.type = null;
        this.init = true;
        this.video = matVideoComponent;
        this.source = el.nativeElement;
        this.init = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.source.src = this.src;
        this.source.type = this.type;
        if (!this.init) {
            this.video.load();
        }
    }
}
MatVideoSourceDirective.ɵfac = function MatVideoSourceDirective_Factory(t) { return new (t || MatVideoSourceDirective)(ɵngcc0.ɵɵdirectiveInject(MatVideoComponent, 1), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
MatVideoSourceDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatVideoSourceDirective, selectors: [["", "matVideoSource", ""]], inputs: { src: "src", type: "type" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
MatVideoSourceDirective.ctorParameters = () => [
    { type: MatVideoComponent, decorators: [{ type: Host }] },
    { type: ElementRef }
];
MatVideoSourceDirective.propDecorators = {
    src: [{ type: Input }],
    type: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatVideoSourceDirective, [{
        type: Directive,
        args: [{
                selector: "[matVideoSource]"
            }]
    }], function () { return [{ type: MatVideoComponent, decorators: [{
                type: Host
            }] }, { type: ɵngcc0.ElementRef }]; }, { src: [{
            type: Input
        }], type: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MatVideoTrackDirective {
    /**
     * @param {?} matVideoComponent
     * @param {?} el
     */
    constructor(matVideoComponent, el) {
        this.matVideoComponent = matVideoComponent;
        this.el = el;
        this.src = null;
        this.kind = null;
        this.srclang = null;
        this.label = null;
        this.init = true;
        this.video = matVideoComponent;
        this.track = el.nativeElement;
        this.init = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.track.src = this.src;
        this.track.kind = this.kind;
        this.track.srclang = this.srclang;
        this.track.label = this.label;
        if (!this.init) {
            this.video.load();
        }
    }
}
MatVideoTrackDirective.ɵfac = function MatVideoTrackDirective_Factory(t) { return new (t || MatVideoTrackDirective)(ɵngcc0.ɵɵdirectiveInject(MatVideoComponent, 1), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
MatVideoTrackDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatVideoTrackDirective, selectors: [["", "matVideoTrack", ""]], inputs: { src: "src", kind: "kind", srclang: "srclang", label: "label" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
MatVideoTrackDirective.ctorParameters = () => [
    { type: MatVideoComponent, decorators: [{ type: Host }] },
    { type: ElementRef }
];
MatVideoTrackDirective.propDecorators = {
    src: [{ type: Input }],
    kind: [{ type: Input }],
    srclang: [{ type: Input }],
    label: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatVideoTrackDirective, [{
        type: Directive,
        args: [{
                selector: "[matVideoTrack]"
            }]
    }], function () { return [{ type: MatVideoComponent, decorators: [{
                type: Host
            }] }, { type: ɵngcc0.ElementRef }]; }, { src: [{
            type: Input
        }], kind: [{
            type: Input
        }], srclang: [{
            type: Input
        }], label: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Counter used to generate unique IDs for progress bars.
 * @type {?}
 */
let sliderprogressbarId = 0;
class MatSliderProgressBarComponent extends MatSlider {
    /**
     * @param {?} elementRef
     * @param {?} focusMonitor
     * @param {?} changeDetectorRef
     * @param {?} dir
     * @param {?} tabIndex
     */
    constructor(elementRef, focusMonitor, changeDetectorRef, dir, tabIndex) {
        super(elementRef, focusMonitor, changeDetectorRef, dir, tabIndex);
        this.mode = "buffer";
        this.value = 0;
        this.pBufferValue = 0;
        /**
         * The id of the progress bar.
         */
        this.sliderprogressbarId = `mat-slider-progress-bar-${sliderprogressbarId++}`;
        this.tabIndex = parseInt(tabIndex, 10) || 0;
    }
    /**
     * Buffer value of the progress bar. Defaults to zero.
     * @return {?}
     */
    get bufferValue() {
        return this.pBufferValue;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set bufferValue(v) {
        this.pBufferValue = clamp(v || 0);
    }
    /**
     * CSS styles for the track fill element.
     * @return {?}
     */
    get _trackBufferStyles() {
        if (this.mode === "buffer") {
            /** @type {?} */
            const axis = this.vertical ? "Y" : "X";
            return {
                transform: `translate${axis}(0px) scale${axis}(${this.pBufferValue / 100})`
            };
        }
    }
}
MatSliderProgressBarComponent.ɵfac = function MatSliderProgressBarComponent_Factory(t) { return new (t || MatSliderProgressBarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FocusMonitor), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Directionality, 8), ɵngcc0.ɵɵinjectAttribute("tabindex")); };
MatSliderProgressBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatSliderProgressBarComponent, selectors: [["mat-slider-progress-bar"]], hostAttrs: ["role", "slider", 1, "mat-slider"], hostVars: 24, hostBindings: function MatSliderProgressBarComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focus", function MatSliderProgressBarComponent_focus_HostBindingHandler() { return ctx._onFocus(); })("blur", function MatSliderProgressBarComponent_blur_HostBindingHandler() { return ctx._onBlur(); })("click", function MatSliderProgressBarComponent_click_HostBindingHandler($event) { return ctx["_onClick"] ? ctx["_onClick"]($event) : null; })("mousedown", function MatSliderProgressBarComponent_mousedown_HostBindingHandler($event) { return ctx["_onMousedown"] ? ctx["_onMousedown"]($event) : null; })("keydown", function MatSliderProgressBarComponent_keydown_HostBindingHandler($event) { return ctx._onKeydown($event); })("keyup", function MatSliderProgressBarComponent_keyup_HostBindingHandler() { return ctx._onKeyup(); })("mouseenter", function MatSliderProgressBarComponent_mouseenter_HostBindingHandler() { return ctx._onMouseenter(); })("slide", function MatSliderProgressBarComponent_slide_HostBindingHandler($event) { return ctx._onSlide($event); })("slideend", function MatSliderProgressBarComponent_slideend_HostBindingHandler() { return ctx._onSlideEnd(); })("slidestart", function MatSliderProgressBarComponent_slidestart_HostBindingHandler($event) { return ctx._onSlideStart($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("tabIndex", ctx.tabIndex);
        ɵngcc0.ɵɵattribute("aria-disabled", ctx.disabled)("aria-valuemax", ctx.max)("aria-valuemin", ctx.min)("aria-valuenow", ctx.value)("aria-orientation", ctx.vertical ? "vertical" : "horizontal");
        ɵngcc0.ɵɵclassProp("mat-slider-disabled", ctx.disabled)("mat-slider-has-ticks", ctx.tickInterval)("mat-slider-horizontal", !ctx.vertical)("mat-slider-axis-inverted", ctx._invertAxis)("mat-slider-sliding", ctx._isSliding)("mat-slider-thumb-label-showing", ctx.thumbLabel)("mat-slider-vertical", ctx.vertical)("mat-slider-min-value", ctx._isMinValue)("mat-slider-hide-last-tick", ctx.disabled || ctx._isMinValue && ctx._thumbGap && ctx._invertAxis);
    } }, inputs: { disabled: "disabled", color: "color", tabIndex: "tabIndex", mode: "mode", value: "value", bufferValue: "bufferValue" }, features: [ɵngcc0.ɵɵProvidersFeature([MAT_SLIDER_VALUE_ACCESSOR]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 18, vars: 8, consts: [[1, "mat-slider-wrapper"], ["sliderWrapper", ""], [1, "mat-slider-track-wrapper"], ["width", "100%", "height", "2", "focusable", "false", 1, "mat-slider-progress-background"], ["x", "2.5", "y", "0", "width", "5", "height", "2.5", "patternUnits", "userSpaceOnUse", 3, "id"], ["cx", "1.25", "cy", "1.25", "r", "1.25"], ["width", "100%", "height", "100%"], [1, "mat-slider-track-fill", "mat-slider-track-buffer", 3, "ngStyle"], [1, "mat-slider-track-fill", 3, "ngStyle"], [1, "mat-slider-ticks-container", 3, "ngStyle"], [1, "mat-slider-ticks", 3, "ngStyle"], [1, "mat-slider-thumb-container", 3, "ngStyle"], [1, "mat-slider-focus-ring"], [1, "mat-slider-thumb"], [1, "mat-slider-thumb-label"], [1, "mat-slider-thumb-label-text"]], template: function MatSliderProgressBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(3, "svg", 3);
        ɵngcc0.ɵɵelementStart(4, "defs");
        ɵngcc0.ɵɵelementStart(5, "pattern", 4);
        ɵngcc0.ɵɵelement(6, "circle", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(7, "rect", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelement(8, "div", 7);
        ɵngcc0.ɵɵelement(9, "div", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(10, "div", 9);
        ɵngcc0.ɵɵelement(11, "div", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(12, "div", 11);
        ɵngcc0.ɵɵelement(13, "div", 12);
        ɵngcc0.ɵɵelement(14, "div", 13);
        ɵngcc0.ɵɵelementStart(15, "div", 14);
        ɵngcc0.ɵɵelementStart(16, "span", 15);
        ɵngcc0.ɵɵtext(17);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("id", ctx.sliderprogressbarId);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("fill", "url(#" + ctx.sliderprogressbarId + ")");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx._trackBufferStyles);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx._trackFillStyles);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx._ticksContainerStyles);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx._ticksStyles);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx._thumbContainerStyles);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵtextInterpolate(ctx.displayValue);
    } }, directives: [ɵngcc1.NgStyle], styles: ["[_nghost-%COMP%]{width:100%}.mat-slider-progress-background[_ngcontent-%COMP%]{position:absolute;height:2px;width:100%;fill:#d3d3d3}.mat-slider-track-buffer[_ngcontent-%COMP%]{background-color:#d3d3d3!important}.mat-slider-thumb[_ngcontent-%COMP%]{border-color:transparent!important;visibility:hidden;opacity:0;transition:visibility .2s,opacity .2s linear}[_nghost-%COMP%]:hover   .mat-slider-thumb[_ngcontent-%COMP%]{visibility:visible;opacity:1;transition:opacity .2s linear}"], changeDetection: 0 });
/** @nocollapse */
MatSliderProgressBarComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: FocusMonitor },
    { type: ChangeDetectorRef },
    { type: Directionality, decorators: [{ type: Optional }] },
    { type: String, decorators: [{ type: Attribute, args: ["tabindex",] }] }
];
MatSliderProgressBarComponent.propDecorators = {
    mode: [{ type: Input }],
    value: [{ type: Input }],
    bufferValue: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatSliderProgressBarComponent, [{
        type: Component,
        args: [{
                selector: "mat-slider-progress-bar",
                template: "<div class=\"mat-slider-wrapper\" #sliderWrapper>\r\n  <div class=\"mat-slider-track-wrapper\">\r\n    <svg width=\"100%\" height=\"2\" focusable=\"false\" class=\"mat-slider-progress-background\">\r\n      <defs>\r\n        <pattern [id]=\"sliderprogressbarId\" x=\"2.5\" y=\"0\" width=\"5\" height=\"2.5\" patternUnits=\"userSpaceOnUse\">\r\n          <circle cx=\"1.25\" cy=\"1.25\" r=\"1.25\" />\r\n        </pattern>\r\n      </defs>\r\n      <rect [attr.fill]=\"'url(#' + sliderprogressbarId + ')'\" width=\"100%\" height=\"100%\" />\r\n    </svg>\r\n    <div class=\"mat-slider-track-fill mat-slider-track-buffer\" [ngStyle]=\"_trackBufferStyles\"></div>\r\n    <div class=\"mat-slider-track-fill\" [ngStyle]=\"_trackFillStyles\"></div>\r\n  </div>\r\n  <div class=\"mat-slider-ticks-container\" [ngStyle]=\"_ticksContainerStyles\">\r\n    <div class=\"mat-slider-ticks\" [ngStyle]=\"_ticksStyles\"></div>\r\n  </div>\r\n  <div class=\"mat-slider-thumb-container\" [ngStyle]=\"_thumbContainerStyles\">\r\n    <div class=\"mat-slider-focus-ring\"></div>\r\n    <div class=\"mat-slider-thumb\"></div>\r\n    <div class=\"mat-slider-thumb-label\">\r\n      <span class=\"mat-slider-thumb-label-text\">{{ displayValue }}</span>\r\n    </div>\r\n  </div>\r\n</div>\r\n",
                providers: [MAT_SLIDER_VALUE_ACCESSOR],
                host: {
                    "(focus)": "_onFocus()",
                    "(blur)": "_onBlur()",
                    "(click)": 'this["_onClick"] ? this["_onClick"]($event) : null',
                    // Angular 5/6 support
                    "(mousedown)": 'this["_onMousedown"] ? this["_onMousedown"]($event) : null',
                    // Angular 7 support
                    "(keydown)": "_onKeydown($event)",
                    "(keyup)": "_onKeyup()",
                    "(mouseenter)": "_onMouseenter()",
                    "(slide)": "_onSlide($event)",
                    "(slideend)": "_onSlideEnd()",
                    "(slidestart)": "_onSlideStart($event)",
                    class: "mat-slider",
                    role: "slider",
                    "[tabIndex]": "tabIndex",
                    "[attr.aria-disabled]": "disabled",
                    "[attr.aria-valuemax]": "max",
                    "[attr.aria-valuemin]": "min",
                    "[attr.aria-valuenow]": "value",
                    "[attr.aria-orientation]": 'vertical ? "vertical" : "horizontal"',
                    "[class.mat-slider-disabled]": "disabled",
                    "[class.mat-slider-has-ticks]": "tickInterval",
                    "[class.mat-slider-horizontal]": "!vertical",
                    "[class.mat-slider-axis-inverted]": "_invertAxis",
                    "[class.mat-slider-sliding]": "_isSliding",
                    "[class.mat-slider-thumb-label-showing]": "thumbLabel",
                    "[class.mat-slider-vertical]": "vertical",
                    "[class.mat-slider-min-value]": "_isMinValue",
                    "[class.mat-slider-hide-last-tick]": "disabled || _isMinValue && _thumbGap && _invertAxis"
                },
                inputs: ["disabled", "color", "tabIndex"],
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{width:100%}.mat-slider-progress-background{position:absolute;height:2px;width:100%;fill:#d3d3d3}.mat-slider-track-buffer{background-color:#d3d3d3!important}.mat-slider-thumb{border-color:transparent!important;visibility:hidden;opacity:0;transition:visibility .2s,opacity .2s linear}:host:hover .mat-slider-thumb{visibility:visible;opacity:1;transition:opacity .2s linear}"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc2.FocusMonitor }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc3.Directionality, decorators: [{
                type: Optional
            }] }, { type: String, decorators: [{
                type: Attribute,
                args: ["tabindex"]
            }] }]; }, { mode: [{
            type: Input
        }], value: [{
            type: Input
        }], bufferValue: [{
            type: Input
        }] }); })();
/**
 * Clamps a value to be between two numbers, by default 0 and 100.
 * @param {?} v
 * @param {?=} min
 * @param {?=} max
 * @return {?}
 */
function clamp(v, min = 0, max = 100) {
    return Math.max(min, Math.min(max, v));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SecondsToTimePipe {
    constructor() {
        this.times = {
            year: 31557600,
            month: 2629746,
            day: 86400,
            hour: 3600
        };
    }
    /**
     * @param {?} seconds
     * @return {?}
     */
    transform(seconds) {
        if (!seconds) {
            return "0:00";
        }
        else {
            /** @type {?} */
            let timeString = "";
            for (const key in this.times) {
                if (Math.floor(seconds / this.times[key]) > 0) {
                    timeString += Math.floor(seconds / this.times[key]).toString() + ":";
                    seconds = seconds - this.times[key] * Math.floor(seconds / this.times[key]);
                }
            }
            timeString += Math.floor(seconds / 60).toString() + ":";
            seconds = seconds - 60 * Math.floor(seconds / 60);
            if (Math.floor(seconds) < 10) {
                timeString += "0";
            }
            timeString += Math.floor(seconds).toString();
            return timeString;
        }
    }
}
SecondsToTimePipe.ɵfac = function SecondsToTimePipe_Factory(t) { return new (t || SecondsToTimePipe)(); };
SecondsToTimePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "secondsToTime", type: SecondsToTimePipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SecondsToTimePipe, [{
        type: Pipe,
        args: [{
                name: "secondsToTime"
            }]
    }], function () { return []; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FullscreenService {
    constructor() {
        this.fnMap = [
            // Object keys
            ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"],
            // New WebKit
            [
                "webkitRequestFullscreen",
                "webkitExitFullscreen",
                "webkitFullscreenElement",
                "webkitFullscreenEnabled",
                "webkitfullscreenchange",
                "webkitfullscreenerror"
            ],
            // Old WebKit (Safari 5.1)
            [
                "webkitRequestFullScreen",
                "webkitCancelFullScreen",
                "webkitCurrentFullScreenElement",
                "webkitCancelFullScreen",
                "webkitfullscreenchange",
                "webkitfullscreenerror"
            ],
            // Mozilla
            [
                "mozRequestFullScreen",
                "mozCancelFullScreen",
                "mozFullScreenElement",
                "mozFullScreenEnabled",
                "mozfullscreenchange",
                "mozfullscreenerror"
            ],
            // MS
            ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]
        ];
        this.keyboardAllowed = typeof Element !== "undefined" && "ALLOW_KEYBOARD_INPUT" in Element;
        /** @type {?} */
        const ret = {};
        /** @type {?} */
        let val;
        for (let i = 0; i < this.fnMap.length; i++) {
            val = this.fnMap[i];
            if (val && val[1] in document) {
                for (i = 0; i < val.length; i++) {
                    // Map everything to the first list of keys
                    ret[this.fnMap[0][i].toString()] = val[i];
                }
                this.fn = ret;
            }
        }
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    request(elem) {
        /** @type {?} */
        const request = this.fn.requestFullscreen;
        elem = elem || document.documentElement;
        // Work around Safari 5.1 bug: reports support for
        // keyboard in fullscreen even though it doesn't.
        // Browser sniffing, since the alternative with
        // setTimeout is even worse.
        if (/5\.1[.\d]* Safari/.test(navigator.userAgent)) {
            elem[request]();
        }
        else {
            elem[request](this.keyboardAllowed ? ((/** @type {?} */ (Element))).ALLOW_KEYBOARD_INPUT : {});
        }
    }
    /**
     * @return {?}
     */
    exit() {
        document[this.fn.exitFullscreen]();
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    toggle(elem) {
        if (this.isFullscreen()) {
            this.exit();
        }
        else {
            this.request(elem);
        }
    }
    /**
     * @param {?} callback
     * @return {?}
     */
    onChange(callback) {
        document.addEventListener(this.fn.fullscreenchange, callback, false);
    }
    /**
     * @param {?} callback
     * @return {?}
     */
    onError(callback) {
        document.addEventListener(this.fn.fullscreenerror, callback, false);
    }
    /**
     * @return {?}
     */
    isFullscreen() {
        return Boolean(document[this.fn.fullscreenElement]);
    }
    /**
     * @return {?}
     */
    isEnabled() {
        // Coerce to boolean in case of old WebKit
        return Boolean(document[this.fn.fullscreenEnabled]);
    }
    /**
     * @return {?}
     */
    getElement() {
        return document[this.fn.fullscreenElement];
    }
}
FullscreenService.ɵfac = function FullscreenService_Factory(t) { return new (t || FullscreenService)(); };
FullscreenService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: FullscreenService, factory: FullscreenService.ɵfac });
/** @nocollapse */
FullscreenService.ctorParameters = () => [];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FullscreenService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MatDownloadButtonComponent {
    constructor() { }
}
MatDownloadButtonComponent.ɵfac = function MatDownloadButtonComponent_Factory(t) { return new (t || MatDownloadButtonComponent)(); };
MatDownloadButtonComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatDownloadButtonComponent, selectors: [["mat-download-button"]], inputs: { video: "video", title: "title" }, decls: 3, vars: 2, consts: [["mat-icon-button", "", 3, "href", "download"]], template: function MatDownloadButtonComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "a", 0);
        ɵngcc0.ɵɵelementStart(1, "mat-icon");
        ɵngcc0.ɵɵtext(2, "file_download");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("href", ctx.video == null ? null : ctx.video.currentSrc, ɵngcc0.ɵɵsanitizeUrl)("download", ctx.title);
    } }, directives: [ɵngcc4.MatAnchor, ɵngcc5.MatIcon], styles: ["a[_ngcontent-%COMP%]{color:inherit;text-decoration:none}"] });
/** @nocollapse */
MatDownloadButtonComponent.ctorParameters = () => [];
MatDownloadButtonComponent.propDecorators = {
    video: [{ type: Input }],
    title: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatDownloadButtonComponent, [{
        type: Component,
        args: [{
                selector: "mat-download-button",
                template: "<a mat-icon-button [href]=\"video?.currentSrc\" [download]=\"title\">\r\n  <mat-icon>file_download</mat-icon>\r\n</a>\r\n",
                styles: ["a{color:inherit;text-decoration:none}"]
            }]
    }], function () { return []; }, { video: [{
            type: Input
        }], title: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MatFrameByFrameControlComponent {
    constructor() {
        this.fps = 29.97;
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @param {?} nbFrames
     * @return {?}
     */
    seekFrames(nbFrames) {
        if (!this.video.paused) {
            this.video.pause();
        }
        /** @type {?} */
        const currentFrames = this.video.currentTime * this.fps;
        /** @type {?} */
        const newPos = (currentFrames + nbFrames) / this.fps + 0.00001;
        this.video.currentTime = newPos;
    }
}
MatFrameByFrameControlComponent.ɵfac = function MatFrameByFrameControlComponent_Factory(t) { return new (t || MatFrameByFrameControlComponent)(); };
MatFrameByFrameControlComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatFrameByFrameControlComponent, selectors: [["mat-frame-by-frame-control"]], inputs: { fps: "fps", video: "video" }, decls: 12, vars: 0, consts: [["mat-icon-button", "", 3, "click"]], template: function MatFrameByFrameControlComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function MatFrameByFrameControlComponent_Template_button_click_0_listener() { return ctx.seekFrames(0 - 5); });
        ɵngcc0.ɵɵelementStart(1, "mat-icon");
        ɵngcc0.ɵɵtext(2, "skip_previous");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "button", 0);
        ɵngcc0.ɵɵlistener("click", function MatFrameByFrameControlComponent_Template_button_click_3_listener() { return ctx.seekFrames(0 - 1); });
        ɵngcc0.ɵɵelementStart(4, "mat-icon");
        ɵngcc0.ɵɵtext(5, "arrow_left");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "button", 0);
        ɵngcc0.ɵɵlistener("click", function MatFrameByFrameControlComponent_Template_button_click_6_listener() { return ctx.seekFrames(1); });
        ɵngcc0.ɵɵelementStart(7, "mat-icon");
        ɵngcc0.ɵɵtext(8, "arrow_right");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(9, "button", 0);
        ɵngcc0.ɵɵlistener("click", function MatFrameByFrameControlComponent_Template_button_click_9_listener() { return ctx.seekFrames(5); });
        ɵngcc0.ɵɵelementStart(10, "mat-icon");
        ɵngcc0.ɵɵtext(11, "skip_next");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } }, directives: [ɵngcc4.MatButton, ɵngcc5.MatIcon], styles: [""] });
/** @nocollapse */
MatFrameByFrameControlComponent.ctorParameters = () => [];
MatFrameByFrameControlComponent.propDecorators = {
    video: [{ type: Input }],
    fps: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatFrameByFrameControlComponent, [{
        type: Component,
        args: [{
                selector: "mat-frame-by-frame-control",
                template: "<button mat-icon-button (click)=\"seekFrames(-5)\">\r\n  <mat-icon>skip_previous</mat-icon>\r\n</button>\r\n\r\n<button mat-icon-button (click)=\"seekFrames(-1)\">\r\n  <mat-icon>arrow_left</mat-icon>\r\n</button>\r\n\r\n<button mat-icon-button (click)=\"seekFrames(1)\">\r\n  <mat-icon>arrow_right</mat-icon>\r\n</button>\r\n\r\n<button mat-icon-button (click)=\"seekFrames(5)\">\r\n  <mat-icon>skip_next</mat-icon>\r\n</button>\r\n",
                styles: [""]
            }]
    }], function () { return []; }, { fps: [{
            type: Input
        }], video: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MatFullscreenButtonComponent {
    /**
     * @param {?} fscreen
     * @param {?} evt
     */
    constructor(fscreen, evt) {
        this.fscreen = fscreen;
        this.evt = evt;
        this.canFullscreen = false;
        this.fullscreen = false;
        this.fullscreenChanged = new EventEmitter();
        this.keyboard = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.fscreen.isEnabled()) {
            this.canFullscreen = true;
        }
        this.fscreen.onChange((/**
         * @param {?} event
         * @return {?}
         */
        event => (this.fscreen.isFullscreen() ? this.onChangesFullscreen(true) : this.onChangesFullscreen(false))));
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setFullscreen(value) {
        if (this.canFullscreen && this.fullscreen !== value) {
            this.toggleFullscreen();
        }
    }
    /**
     * @return {?}
     */
    toggleFullscreen() {
        this.fullscreen = !this.fullscreen;
        this.updateFullscreen();
    }
    /**
     * @return {?}
     */
    updateFullscreen() {
        this.fullscreen ? this.fscreen.request(this.player) : this.fscreen.exit();
        this.fullscreenChanged.emit(this.fullscreen);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onChangesFullscreen(value) {
        this.fullscreen = value;
        this.fullscreenChanged.emit(this.fullscreen);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFullscreenKey(event) {
        if (this.keyboard) {
            this.toggleFullscreen();
            event.preventDefault();
        }
    }
}
MatFullscreenButtonComponent.ɵfac = function MatFullscreenButtonComponent_Factory(t) { return new (t || MatFullscreenButtonComponent)(ɵngcc0.ɵɵdirectiveInject(FullscreenService), ɵngcc0.ɵɵdirectiveInject(EventService)); };
MatFullscreenButtonComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatFullscreenButtonComponent, selectors: [["mat-fullscreen-button"]], hostBindings: function MatFullscreenButtonComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keyup.f", function MatFullscreenButtonComponent_keyup_f_HostBindingHandler($event) { return ctx.onFullscreenKey($event); }, false, ɵngcc0.ɵɵresolveDocument);
    } }, inputs: { fullscreen: "fullscreen", keyboard: "keyboard", player: "player" }, outputs: { fullscreenChanged: "fullscreenChanged" }, decls: 3, vars: 3, consts: [["mat-icon-button", "", 3, "disabled", "click"], [4, "ngIf"]], template: function MatFullscreenButtonComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function MatFullscreenButtonComponent_Template_button_click_0_listener() { return ctx.toggleFullscreen(); });
        ɵngcc0.ɵɵtemplate(1, MatFullscreenButtonComponent_mat_icon_1_Template, 2, 0, "mat-icon", 1);
        ɵngcc0.ɵɵtemplate(2, MatFullscreenButtonComponent_mat_icon_2_Template, 2, 0, "mat-icon", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("disabled", !ctx.canFullscreen);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.fullscreen);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.fullscreen);
    } }, directives: [ɵngcc4.MatButton, ɵngcc1.NgIf, ɵngcc5.MatIcon], styles: [""] });
/** @nocollapse */
MatFullscreenButtonComponent.ctorParameters = () => [
    { type: FullscreenService },
    { type: EventService }
];
MatFullscreenButtonComponent.propDecorators = {
    player: [{ type: Input }],
    fullscreen: [{ type: Input }],
    fullscreenChanged: [{ type: Output }],
    keyboard: [{ type: Input }],
    onFullscreenKey: [{ type: HostListener, args: ["document:keyup.f", ["$event"],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatFullscreenButtonComponent, [{
        type: Component,
        args: [{
                selector: "mat-fullscreen-button",
                template: "<button mat-icon-button [disabled]=\"!canFullscreen\" (click)=\"toggleFullscreen()\">\r\n  <mat-icon *ngIf=\"!fullscreen\">fullscreen</mat-icon>\r\n  <mat-icon *ngIf=\"fullscreen\">fullscreen_exit</mat-icon>\r\n</button>\r\n",
                styles: [""]
            }]
    }], function () { return [{ type: FullscreenService }, { type: EventService }]; }, { fullscreen: [{
            type: Input
        }], fullscreenChanged: [{
            type: Output
        }], keyboard: [{
            type: Input
        }], onFullscreenKey: [{
            type: HostListener,
            args: ["document:keyup.f", ["$event"]]
        }], player: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MatPlayButtonComponent {
    /**
     * @param {?} renderer
     * @param {?} evt
     */
    constructor(renderer, evt) {
        this.renderer = renderer;
        this.evt = evt;
        this.play = false;
        this.playChanged = new EventEmitter();
        this.keyboard = true;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.events = [
            { element: this.video, name: "play", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                event => this.setVideoPlayback(true)), dispose: null },
            { element: this.video, name: "pause", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                event => this.setVideoPlayback(false)), dispose: null },
            { element: this.video, name: "durationchange", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                event => this.setVideoPlayback(false)), dispose: null },
            { element: this.video, name: "ended", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                event => this.setVideoPlayback(false)), dispose: null },
            { element: this.video, name: "click", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                event => this.toggleVideoPlayback()), dispose: null }
        ];
        this.evt.addEvents(this.renderer, this.events);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.evt.removeEvents(this.events);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setVideoPlayback(value) {
        if (this.play !== value) {
            this.toggleVideoPlayback();
        }
    }
    /**
     * @return {?}
     */
    toggleVideoPlayback() {
        this.play = !this.play;
        this.updateVideoPlayback();
    }
    /**
     * @return {?}
     */
    updateVideoPlayback() {
        this.play ? this.video.play() : this.video.pause();
        this.playChanged.emit(this.play);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onPlayKey(event) {
        if (this.keyboard) {
            this.toggleVideoPlayback();
            event.preventDefault();
        }
    }
}
MatPlayButtonComponent.ɵfac = function MatPlayButtonComponent_Factory(t) { return new (t || MatPlayButtonComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(EventService)); };
MatPlayButtonComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatPlayButtonComponent, selectors: [["mat-play-button"]], hostBindings: function MatPlayButtonComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keyup.space", function MatPlayButtonComponent_keyup_space_HostBindingHandler($event) { return ctx.onPlayKey($event); }, false, ɵngcc0.ɵɵresolveDocument);
    } }, inputs: { play: "play", keyboard: "keyboard", video: "video" }, outputs: { playChanged: "playChanged" }, decls: 3, vars: 2, consts: [["mat-icon-button", "", 3, "click"], [4, "ngIf"]], template: function MatPlayButtonComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function MatPlayButtonComponent_Template_button_click_0_listener() { return ctx.toggleVideoPlayback(); });
        ɵngcc0.ɵɵtemplate(1, MatPlayButtonComponent_mat_icon_1_Template, 2, 0, "mat-icon", 1);
        ɵngcc0.ɵɵtemplate(2, MatPlayButtonComponent_mat_icon_2_Template, 2, 0, "mat-icon", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.play);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.play);
    } }, directives: [ɵngcc4.MatButton, ɵngcc1.NgIf, ɵngcc5.MatIcon], styles: [""] });
/** @nocollapse */
MatPlayButtonComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: EventService }
];
MatPlayButtonComponent.propDecorators = {
    video: [{ type: Input }],
    play: [{ type: Input }],
    playChanged: [{ type: Output }],
    keyboard: [{ type: Input }],
    onPlayKey: [{ type: HostListener, args: ["document:keyup.space", ["$event"],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatPlayButtonComponent, [{
        type: Component,
        args: [{
                selector: "mat-play-button",
                template: "<button mat-icon-button (click)=\"toggleVideoPlayback()\">\r\n  <mat-icon *ngIf=\"!play\">play_arrow</mat-icon>\r\n  <mat-icon *ngIf=\"play\">pause</mat-icon>\r\n</button>\r\n",
                styles: [""]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: EventService }]; }, { play: [{
            type: Input
        }], playChanged: [{
            type: Output
        }], keyboard: [{
            type: Input
        }], onPlayKey: [{
            type: HostListener,
            args: ["document:keyup.space", ["$event"]]
        }], video: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MatQualityControlComponent {
    constructor() { }
}
MatQualityControlComponent.ɵfac = function MatQualityControlComponent_Factory(t) { return new (t || MatQualityControlComponent)(); };
MatQualityControlComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatQualityControlComponent, selectors: [["mat-quality-control"]], inputs: { video: "video" }, decls: 1, vars: 1, consts: [["class", "quality", 4, "ngIf"], [1, "quality"]], template: function MatQualityControlComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, MatQualityControlComponent_div_0_Template, 2, 1, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.video && ctx.video.videoHeight);
    } }, directives: [ɵngcc1.NgIf], styles: [".quality[_ngcontent-%COMP%]{display:inline-block;font-size:12px;padding-left:12px;padding-right:12px}"] });
/** @nocollapse */
MatQualityControlComponent.ctorParameters = () => [];
MatQualityControlComponent.propDecorators = {
    video: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatQualityControlComponent, [{
        type: Component,
        args: [{
                selector: "mat-quality-control",
                template: "<div *ngIf=\"video && video.videoHeight\" class=\"quality\">{{ video.videoHeight }}p</div>\r\n",
                styles: [".quality{display:inline-block;font-size:12px;padding-left:12px;padding-right:12px}"]
            }]
    }], function () { return []; }, { video: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MatSeekProgressControlComponent {
    /**
     * @param {?} renderer
     * @param {?} evt
     */
    constructor(renderer, evt) {
        this.renderer = renderer;
        this.evt = evt;
        this.curTimePercent = 0;
        this.bufTimePercent = 0;
        this.video = null;
        this.color = "primary";
        this.currentTime = 0;
        this.currentTimeChanged = new EventEmitter();
        this.bufferedTime = 0;
        this.bufferedTimeChanged = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.events = [
            { element: this.video, name: "seeking", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                event => this.updateCurrentTime(this.video.currentTime)), dispose: null },
            { element: this.video, name: "canplaythrough", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                event => this.updateBufferedTime()), dispose: null },
            { element: this.video, name: "timeupdate", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                event => this.updateCurrentTime(this.video.currentTime)), dispose: null },
            { element: this.video, name: "progress", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                event => this.updateBufferedTime()), dispose: null }
        ];
        this.evt.addEvents(this.renderer, this.events);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.evt.removeEvents(this.events);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    seekVideo(value) {
        /** @type {?} */
        const percentage = value / 100;
        /** @type {?} */
        const newTime = this.video.duration * percentage;
        this.video.currentTime = newTime;
    }
    /**
     * @param {?} time
     * @return {?}
     */
    updateCurrentTime(time) {
        this.currentTime = time;
        this.curTimePercent = this.updateTime(this.currentTimeChanged, this.currentTime);
    }
    /**
     * @return {?}
     */
    updateBufferedTime() {
        if (this.video.buffered.length > 0) {
            /** @type {?} */
            let largestBufferValue = 0;
            for (let i = 0; i < this.video.buffered.length; i++) {
                /** @type {?} */
                const cur = this.video.currentTime;
                /** @type {?} */
                const start = this.video.buffered.start(i);
                /** @type {?} */
                const end = this.video.buffered.end(i);
                if (start <= cur && end > cur && end - start > largestBufferValue) {
                    largestBufferValue = end;
                }
            }
            this.bufferedTime = largestBufferValue;
            this.bufTimePercent = this.updateTime(this.bufferedTimeChanged, this.bufferedTime);
        }
    }
    /**
     * @param {?} emitter
     * @param {?} time
     * @return {?}
     */
    updateTime(emitter, time) {
        emitter.emit(time);
        return (time / this.video.duration) * 100;
    }
}
MatSeekProgressControlComponent.ɵfac = function MatSeekProgressControlComponent_Factory(t) { return new (t || MatSeekProgressControlComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(EventService)); };
MatSeekProgressControlComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatSeekProgressControlComponent, selectors: [["mat-seek-progress-control"]], inputs: { video: "video", color: "color", currentTime: "currentTime", bufferedTime: "bufferedTime" }, outputs: { currentTimeChanged: "currentTimeChanged", bufferedTimeChanged: "bufferedTimeChanged" }, decls: 1, vars: 3, consts: [["mode", "buffer", "step", "0.01", 3, "color", "value", "bufferValue", "input"]], template: function MatSeekProgressControlComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "mat-slider-progress-bar", 0);
        ɵngcc0.ɵɵlistener("input", function MatSeekProgressControlComponent_Template_mat_slider_progress_bar_input_0_listener($event) { return ctx.seekVideo($event.value); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("color", ctx.color)("value", ctx.curTimePercent)("bufferValue", ctx.bufTimePercent);
    } }, directives: [MatSliderProgressBarComponent], styles: [""] });
/** @nocollapse */
MatSeekProgressControlComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: EventService }
];
MatSeekProgressControlComponent.propDecorators = {
    video: [{ type: Input }],
    color: [{ type: Input }],
    currentTime: [{ type: Input }],
    currentTimeChanged: [{ type: Output }],
    bufferedTime: [{ type: Input }],
    bufferedTimeChanged: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatSeekProgressControlComponent, [{
        type: Component,
        args: [{
                selector: "mat-seek-progress-control",
                template: "<mat-slider-progress-bar\r\n  [color]=\"color\"\r\n  mode=\"buffer\"\r\n  step=\"0.01\"\r\n  [value]=\"curTimePercent\"\r\n  [bufferValue]=\"bufTimePercent\"\r\n  (input)=\"seekVideo($event.value)\"\r\n></mat-slider-progress-bar>\r\n",
                styles: [""]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: EventService }]; }, { video: [{
            type: Input
        }], color: [{
            type: Input
        }], currentTime: [{
            type: Input
        }], currentTimeChanged: [{
            type: Output
        }], bufferedTime: [{
            type: Input
        }], bufferedTimeChanged: [{
            type: Output
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MatTimeControlComponent {
    constructor() { }
}
MatTimeControlComponent.ɵfac = function MatTimeControlComponent_Factory(t) { return new (t || MatTimeControlComponent)(); };
MatTimeControlComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatTimeControlComponent, selectors: [["mat-time-control"]], inputs: { video: "video" }, decls: 4, vars: 6, consts: [[1, "playtime"]], template: function MatTimeControlComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵpipe(2, "secondsToTime");
        ɵngcc0.ɵɵpipe(3, "secondsToTime");
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate2("", ɵngcc0.ɵɵpipeBind1(2, 2, ctx.video == null ? null : ctx.video.currentTime), " / ", ɵngcc0.ɵɵpipeBind1(3, 4, ctx.video == null ? null : ctx.video.duration), "");
    } }, pipes: [SecondsToTimePipe], styles: [".playtime[_ngcontent-%COMP%]{display:inline;font-size:12px}"] });
/** @nocollapse */
MatTimeControlComponent.ctorParameters = () => [];
MatTimeControlComponent.propDecorators = {
    video: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatTimeControlComponent, [{
        type: Component,
        args: [{
                selector: "mat-time-control",
                template: "<div class=\"playtime\">{{ video?.currentTime | secondsToTime }} / {{ video?.duration | secondsToTime }}</div>\r\n",
                styles: [".playtime{display:inline;font-size:12px}"]
            }]
    }], function () { return []; }, { video: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MatVideoSpinnerComponent {
    /**
     * @param {?} renderer
     * @param {?} evt
     */
    constructor(renderer, evt) {
        this.renderer = renderer;
        this.evt = evt;
        this.spinner = "spin";
        this.videoBuffering = false;
        this.videoLoaded = false;
        this.events = [];
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.events = [
            { element: this.video, name: "loadstart", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                event => (this.videoLoaded = false)), dispose: null },
            { element: this.video, name: "loadedmetadata", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                event => (this.videoLoaded = true)), dispose: null },
            { element: this.video, name: "canplay", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                event => (this.videoBuffering = false)), dispose: null },
            { element: this.video, name: "waiting", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                event => (this.videoBuffering = true)), dispose: null },
            { element: this.video, name: "durationchange", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                event => (this.videoBuffering = true)), dispose: null }
        ];
        this.video.onloadeddata = (/**
         * @return {?}
         */
        () => (this.videoLoaded = true));
        this.evt.addEvents(this.renderer, this.events);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.video.onloadeddata = null;
        this.evt.removeEvents(this.events);
    }
}
MatVideoSpinnerComponent.ɵfac = function MatVideoSpinnerComponent_Factory(t) { return new (t || MatVideoSpinnerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(EventService)); };
MatVideoSpinnerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatVideoSpinnerComponent, selectors: [["mat-video-spinner"]], inputs: { spinner: "spinner", video: "video" }, decls: 1, vars: 1, consts: [[3, "class", 4, "ngIf"]], template: function MatVideoSpinnerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, MatVideoSpinnerComponent_div_0_Template, 1, 2, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.videoLoaded || ctx.videoBuffering);
    } }, directives: [ɵngcc1.NgIf], styles: ["[_nghost-%COMP%]{position:absolute;left:calc(50% - 32px);top:calc(50% - 32px);z-index:1}", ".spin[_ngcontent-%COMP%]{box-sizing:border-box;width:64px;height:64px;border-radius:100%;border:10px solid rgba(255,255,255,.2);border-top-color:#fff;-webkit-animation:1s linear infinite spin;animation:1s linear infinite spin}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(360deg)}}@keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}", ".dot[_ngcontent-%COMP%]{width:64px;height:64px;background-color:#fff;border-radius:100%;-webkit-animation:1s ease-in-out infinite dot;animation:1s ease-in-out infinite dot}@-webkit-keyframes dot{0%{-webkit-transform:scale(0)}100%{-webkit-transform:scale(1);opacity:0}}@keyframes dot{0%{transform:scale(0)}100%{transform:scale(1);opacity:0}}", ".split-ring[_ngcontent-%COMP%]{display:inline-block;width:64px;height:64px}.split-ring[_ngcontent-%COMP%]:after{content:\" \";display:block;width:46px;height:46px;margin:1px;border-radius:50%;border:5px solid #fff;border-color:#fff transparent;-webkit-animation:1.2s linear infinite split-ring;animation:1.2s linear infinite split-ring}@-webkit-keyframes split-ring{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(360deg)}}@keyframes split-ring{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}", ".hourglass[_ngcontent-%COMP%]{display:inline-block;position:relative;width:64px;height:64px}.hourglass[_ngcontent-%COMP%]:after{content:\" \";display:block;border-radius:50%;width:0;height:0;margin:6px;box-sizing:border-box;border:26px solid #fff;border-color:#fff transparent;-webkit-animation:1.2s infinite hourglass;animation:1.2s infinite hourglass}@-webkit-keyframes hourglass{0%{-webkit-transform:rotate(0);-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19)}50%{-webkit-transform:rotate(360deg);-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1)}100%{-webkit-transform:rotate(720deg)}}@keyframes hourglass{0%{transform:rotate(0);-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19);animation-timing-function:cubic-bezier(.55,.055,.675,.19)}50%{transform:rotate(360deg);-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}100%{transform:rotate(720deg)}}"] });
/** @nocollapse */
MatVideoSpinnerComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: EventService }
];
MatVideoSpinnerComponent.propDecorators = {
    video: [{ type: Input }],
    spinner: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatVideoSpinnerComponent, [{
        type: Component,
        args: [{
                selector: "mat-video-spinner",
                template: "<div *ngIf=\"!videoLoaded || videoBuffering\" [class]=\"spinner\"></div>\r\n",
                styles: [":host{position:absolute;left:calc(50% - 32px);top:calc(50% - 32px);z-index:1}", ".spin{box-sizing:border-box;width:64px;height:64px;border-radius:100%;border:10px solid rgba(255,255,255,.2);border-top-color:#fff;-webkit-animation:1s linear infinite spin;animation:1s linear infinite spin}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(360deg)}}@keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}", ".dot{width:64px;height:64px;background-color:#fff;border-radius:100%;-webkit-animation:1s ease-in-out infinite dot;animation:1s ease-in-out infinite dot}@-webkit-keyframes dot{0%{-webkit-transform:scale(0)}100%{-webkit-transform:scale(1);opacity:0}}@keyframes dot{0%{transform:scale(0)}100%{transform:scale(1);opacity:0}}", ".split-ring{display:inline-block;width:64px;height:64px}.split-ring:after{content:\" \";display:block;width:46px;height:46px;margin:1px;border-radius:50%;border:5px solid #fff;border-color:#fff transparent;-webkit-animation:1.2s linear infinite split-ring;animation:1.2s linear infinite split-ring}@-webkit-keyframes split-ring{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(360deg)}}@keyframes split-ring{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}", ".hourglass{display:inline-block;position:relative;width:64px;height:64px}.hourglass:after{content:\" \";display:block;border-radius:50%;width:0;height:0;margin:6px;box-sizing:border-box;border:26px solid #fff;border-color:#fff transparent;-webkit-animation:1.2s infinite hourglass;animation:1.2s infinite hourglass}@-webkit-keyframes hourglass{0%{-webkit-transform:rotate(0);-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19)}50%{-webkit-transform:rotate(360deg);-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1)}100%{-webkit-transform:rotate(720deg)}}@keyframes hourglass{0%{transform:rotate(0);-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19);animation-timing-function:cubic-bezier(.55,.055,.675,.19)}50%{transform:rotate(360deg);-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}100%{transform:rotate(720deg)}}"]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: EventService }]; }, { spinner: [{
            type: Input
        }], video: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MatVolumeControlComponent {
    /**
     * @param {?} evt
     */
    constructor(evt) {
        this.evt = evt;
        this.video = null;
        this.color = "primary";
        this.volume = 1;
        this.volumeChanged = new EventEmitter();
        this.muted = false;
        this.mutedChanged = new EventEmitter();
        this.keyboard = true;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.updateMuted(false);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.muted) {
            this.updateMuted(false);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setVolume(value) {
        this.volume = value;
        this.video.volume = this.volume;
        this.volumeChanged.emit(this.volume);
        if (this.volume > 0) {
            this.setMuted(false);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setMuted(value) {
        if (this.muted !== value) {
            this.toggleMuted();
        }
    }
    /**
     * @return {?}
     */
    toggleMuted() {
        this.muted = !this.muted;
        this.updateMuted();
    }
    /**
     * @param {?=} emitChange
     * @return {?}
     */
    updateMuted(emitChange = true) {
        if (this.video) {
            this.video.muted = this.muted;
        }
        if (emitChange) {
            this.mutedChanged.emit(this.muted);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMuteKey(event) {
        if (this.keyboard) {
            this.toggleMuted();
            event.preventDefault();
        }
    }
}
MatVolumeControlComponent.ɵfac = function MatVolumeControlComponent_Factory(t) { return new (t || MatVolumeControlComponent)(ɵngcc0.ɵɵdirectiveInject(EventService)); };
MatVolumeControlComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatVolumeControlComponent, selectors: [["mat-volume-control"]], hostBindings: function MatVolumeControlComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keyup.m", function MatVolumeControlComponent_keyup_m_HostBindingHandler($event) { return ctx.onMuteKey($event); }, false, ɵngcc0.ɵɵresolveDocument);
    } }, inputs: { video: "video", color: "color", volume: "volume", muted: "muted", keyboard: "keyboard" }, outputs: { volumeChanged: "volumeChanged", mutedChanged: "mutedChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 7, vars: 5, consts: [[1, "volume-control"], ["mat-icon-button", "", 3, "click"], [4, "ngIf"], ["min", "0", "max", "1", "step", "0.01", "value", "1", 1, "volume-slider", 3, "color", "input"]], template: function MatVolumeControlComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "button", 1);
        ɵngcc0.ɵɵlistener("click", function MatVolumeControlComponent_Template_button_click_1_listener() { return ctx.toggleMuted(); });
        ɵngcc0.ɵɵtemplate(2, MatVolumeControlComponent_mat_icon_2_Template, 2, 0, "mat-icon", 2);
        ɵngcc0.ɵɵtemplate(3, MatVolumeControlComponent_mat_icon_3_Template, 2, 0, "mat-icon", 2);
        ɵngcc0.ɵɵtemplate(4, MatVolumeControlComponent_mat_icon_4_Template, 2, 0, "mat-icon", 2);
        ɵngcc0.ɵɵtemplate(5, MatVolumeControlComponent_mat_icon_5_Template, 2, 0, "mat-icon", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "mat-slider", 3);
        ɵngcc0.ɵɵlistener("input", function MatVolumeControlComponent_Template_mat_slider_input_6_listener($event) { return ctx.setVolume($event.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.muted || ctx.volume === 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.muted && ctx.volume > 0 && ctx.volume < 0.25);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.muted && ctx.volume >= 0.25 && ctx.volume < 0.5);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.muted && ctx.volume >= 0.5);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("color", ctx.color);
    } }, directives: [ɵngcc4.MatButton, ɵngcc1.NgIf, ɵngcc6.MatSlider, ɵngcc5.MatIcon], styles: [".volume-control[_ngcontent-%COMP%]{display:inline}.volume-slider[_ngcontent-%COMP%]{margin-left:-15px} .mat-slider-thumb{border-color:transparent!important} .mat-slider-track-background{background-color:#d3d3d3!important;transform:translateX(0)!important}.volume-control[_ngcontent-%COMP%]   .volume-slider[_ngcontent-%COMP%]{visibility:hidden;opacity:0;min-width:0;width:0;transition:visibility .2s,opacity .2s linear,width .2s linear}.volume-control[_ngcontent-%COMP%]:hover   .volume-slider[_ngcontent-%COMP%]{visibility:visible;opacity:1;min-width:90px;width:90px;transition:opacity .2s linear,width .2s linear,min-width .2s linear}"] });
/** @nocollapse */
MatVolumeControlComponent.ctorParameters = () => [
    { type: EventService }
];
MatVolumeControlComponent.propDecorators = {
    video: [{ type: Input }],
    color: [{ type: Input }],
    volume: [{ type: Input }],
    volumeChanged: [{ type: Output }],
    muted: [{ type: Input }],
    mutedChanged: [{ type: Output }],
    keyboard: [{ type: Input }],
    onMuteKey: [{ type: HostListener, args: ["document:keyup.m", ["$event"],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatVolumeControlComponent, [{
        type: Component,
        args: [{
                selector: "mat-volume-control",
                template: "<div class=\"volume-control\">\r\n  <button mat-icon-button (click)=\"toggleMuted()\">\r\n    <mat-icon *ngIf=\"muted || volume === 0\">volume_off</mat-icon>\r\n    <mat-icon *ngIf=\"!muted && volume > 0 && volume < 0.25\">volume_mute</mat-icon>\r\n    <mat-icon *ngIf=\"!muted && volume >= 0.25 && volume < 0.5\">volume_down</mat-icon>\r\n    <mat-icon *ngIf=\"!muted && volume >= 0.5\">volume_up</mat-icon>\r\n  </button>\r\n  <mat-slider class=\"volume-slider\" [color]=\"color\" min=\"0\" max=\"1\" step=\"0.01\" value=\"1\" (input)=\"setVolume($event.value)\"> </mat-slider>\r\n</div>\r\n",
                styles: [".volume-control{display:inline}.volume-slider{margin-left:-15px}::ng-deep.mat-slider-thumb{border-color:transparent!important}::ng-deep.mat-slider-track-background{background-color:#d3d3d3!important;transform:translateX(0)!important}.volume-control .volume-slider{visibility:hidden;opacity:0;min-width:0;width:0;transition:visibility .2s,opacity .2s linear,width .2s linear}.volume-control:hover .volume-slider{visibility:visible;opacity:1;min-width:90px;width:90px;transition:opacity .2s linear,width .2s linear,min-width .2s linear}"]
            }]
    }], function () { return [{ type: EventService }]; }, { video: [{
            type: Input
        }], color: [{
            type: Input
        }], volume: [{
            type: Input
        }], volumeChanged: [{
            type: Output
        }], muted: [{
            type: Input
        }], mutedChanged: [{
            type: Output
        }], keyboard: [{
            type: Input
        }], onMuteKey: [{
            type: HostListener,
            args: ["document:keyup.m", ["$event"]]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MatVideoModule {
}
MatVideoModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MatVideoModule });
MatVideoModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MatVideoModule_Factory(t) { return new (t || MatVideoModule)(); }, providers: [FullscreenService, EventService], imports: [[CommonModule, MatIconModule, MatButtonModule, MatSliderModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatVideoModule, { declarations: function () { return [SecondsToTimePipe,
        MatVideoComponent,
        MatSliderProgressBarComponent,
        MatPlayButtonComponent,
        MatVolumeControlComponent,
        MatDownloadButtonComponent,
        MatFullscreenButtonComponent,
        MatTimeControlComponent,
        MatQualityControlComponent,
        MatVideoSpinnerComponent,
        MatSeekProgressControlComponent,
        MatVideoSourceDirective,
        MatVideoTrackDirective,
        MatFrameByFrameControlComponent]; }, imports: function () { return [CommonModule, MatIconModule, MatButtonModule, MatSliderModule]; }, exports: function () { return [MatVideoComponent,
        MatVideoSourceDirective,
        MatVideoTrackDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatVideoModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    SecondsToTimePipe,
                    MatVideoComponent,
                    MatSliderProgressBarComponent,
                    MatPlayButtonComponent,
                    MatVolumeControlComponent,
                    MatDownloadButtonComponent,
                    MatFullscreenButtonComponent,
                    MatTimeControlComponent,
                    MatQualityControlComponent,
                    MatVideoSpinnerComponent,
                    MatSeekProgressControlComponent,
                    MatVideoSourceDirective,
                    MatVideoTrackDirective,
                    MatFrameByFrameControlComponent
                ],
                imports: [CommonModule, MatIconModule, MatButtonModule, MatSliderModule],
                exports: [MatVideoComponent, MatVideoSourceDirective, MatVideoTrackDirective],
                providers: [FullscreenService, EventService]
            }]
    }], null, null); })();

export { MatVideoModule, SecondsToTimePipe as ɵa, MatVideoComponent as ɵb, EventService as ɵc, MatSliderProgressBarComponent as ɵd, MatPlayButtonComponent as ɵe, MatVolumeControlComponent as ɵf, MatDownloadButtonComponent as ɵg, MatFullscreenButtonComponent as ɵh, FullscreenService as ɵi, MatTimeControlComponent as ɵj, MatQualityControlComponent as ɵk, MatVideoSpinnerComponent as ɵl, MatSeekProgressControlComponent as ɵm, MatVideoSourceDirective as ɵn, MatVideoTrackDirective as ɵo, MatFrameByFrameControlComponent as ɵp };

//# sourceMappingURL=mat-video.js.map