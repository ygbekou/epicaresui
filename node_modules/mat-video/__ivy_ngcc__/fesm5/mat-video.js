import { CommonModule } from '@angular/common';
import { Injectable, Component, Renderer2, ViewChild, Input, Output, EventEmitter, Directive, Host, ElementRef, ChangeDetectionStrategy, ChangeDetectorRef, Optional, Attribute, Pipe, HostListener, NgModule } from '@angular/core';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MAT_SLIDER_VALUE_ACCESSOR, MatSlider, MatSliderModule } from '@angular/material/slider';
import { __values, __extends } from 'tslib';
import { FocusMonitor } from '@angular/cdk/a11y';
import { Directionality } from '@angular/cdk/bidi';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@angular/cdk/a11y';
import * as ɵngcc3 from '@angular/cdk/bidi';
import * as ɵngcc4 from '@angular/material/button';
import * as ɵngcc5 from '@angular/material/icon';
import * as ɵngcc6 from '@angular/material/slider';

var _c0 = ["player"];
var _c1 = ["video"];
function MatVideoComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 7);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r1.getOverlayClass("visible", "hidden"));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.title, " ");
} }
function MatVideoComponent_div_8_mat_frame_by_frame_control_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "mat-frame-by-frame-control", 21);
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    var _r2 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵproperty("video", _r2)("fps", ctx_r4.fps);
} }
function MatVideoComponent_div_8_mat_quality_control_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "mat-quality-control", 16);
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    var _r2 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵproperty("video", _r2);
} }
function MatVideoComponent_div_8_mat_download_button_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "mat-download-button", 22);
} if (rf & 2) {
    var ctx_r6 = ɵngcc0.ɵɵnextContext(2);
    var _r2 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵproperty("title", ctx_r6.title)("video", _r2);
} }
function MatVideoComponent_div_8_mat_fullscreen_button_12_Template(rf, ctx) { if (rf & 1) {
    var _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "mat-fullscreen-button", 23);
    ɵngcc0.ɵɵlistener("fullscreenChanged", function MatVideoComponent_div_8_mat_fullscreen_button_12_Template_mat_fullscreen_button_fullscreenChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var ctx_r8 = ɵngcc0.ɵɵnextContext(2); return ctx_r8.isFullscreen = $event; });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    var _r0 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵproperty("player", _r0)("keyboard", ctx_r7.keyboard);
} }
function MatVideoComponent_div_8_Template(rf, ctx) { if (rf & 1) {
    var _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵelementStart(1, "div", 9);
    ɵngcc0.ɵɵelement(2, "mat-seek-progress-control", 10);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "div", 11);
    ɵngcc0.ɵɵelementStart(4, "div", 12);
    ɵngcc0.ɵɵelementStart(5, "mat-play-button", 13);
    ɵngcc0.ɵɵlistener("playChanged", function MatVideoComponent_div_8_Template_mat_play_button_playChanged_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); var ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.playing = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(6, MatVideoComponent_div_8_mat_frame_by_frame_control_6_Template, 1, 2, "mat-frame-by-frame-control", 14);
    ɵngcc0.ɵɵelementStart(7, "mat-volume-control", 15);
    ɵngcc0.ɵɵlistener("mutedChanged", function MatVideoComponent_div_8_Template_mat_volume_control_mutedChanged_7_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); var ctx_r12 = ɵngcc0.ɵɵnextContext(); ctx_r12.muted = $event; return ctx_r12.mutedChange.emit(ctx_r12.muted); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(8, "mat-time-control", 16);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(9, "div", 17);
    ɵngcc0.ɵɵtemplate(10, MatVideoComponent_div_8_mat_quality_control_10_Template, 1, 1, "mat-quality-control", 18);
    ɵngcc0.ɵɵtemplate(11, MatVideoComponent_div_8_mat_download_button_11_Template, 1, 2, "mat-download-button", 19);
    ɵngcc0.ɵɵtemplate(12, MatVideoComponent_div_8_mat_fullscreen_button_12_Template, 1, 2, "mat-fullscreen-button", 20);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    var _r2 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r3.getOverlayClass("visible", "hidden"));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("color", ctx_r3.color)("video", _r2);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("video", _r2)("keyboard", ctx_r3.keyboard);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.showFrameByFrame);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("muted", ctx_r3.muted)("color", ctx_r3.color)("video", _r2)("keyboard", ctx_r3.keyboard);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("video", _r2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.quality);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.download);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.fullscreen);
} }
var _c2 = [[["source"]], [["track"]]];
var _c3 = ["source", "track"];
function MatFullscreenButtonComponent_mat_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "fullscreen");
    ɵngcc0.ɵɵelementEnd();
} }
function MatFullscreenButtonComponent_mat_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "fullscreen_exit");
    ɵngcc0.ɵɵelementEnd();
} }
function MatPlayButtonComponent_mat_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "play_arrow");
    ɵngcc0.ɵɵelementEnd();
} }
function MatPlayButtonComponent_mat_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "pause");
    ɵngcc0.ɵɵelementEnd();
} }
function MatQualityControlComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", ctx_r0.video.videoHeight, "p");
} }
function MatVideoSpinnerComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div");
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMap(ctx_r0.spinner);
} }
function MatVolumeControlComponent_mat_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "volume_off");
    ɵngcc0.ɵɵelementEnd();
} }
function MatVolumeControlComponent_mat_icon_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "volume_mute");
    ɵngcc0.ɵɵelementEnd();
} }
function MatVolumeControlComponent_mat_icon_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "volume_down");
    ɵngcc0.ɵɵelementEnd();
} }
function MatVolumeControlComponent_mat_icon_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "volume_up");
    ɵngcc0.ɵɵelementEnd();
} }
var EventService = /** @class */ (function () {
    function EventService() {
    }
    /**
     * @param {?} renderer
     * @param {?} events
     * @return {?}
     */
    EventService.prototype.addEvents = /**
     * @param {?} renderer
     * @param {?} events
     * @return {?}
     */
    function (renderer, events) {
        var e_1, _a;
        var _loop_1 = function (event_1) {
            event_1.dispose = renderer.listen(event_1.element, event_1.name, (/**
             * @param {?} newEvent
             * @return {?}
             */
            function (newEvent) { return event_1.callback(newEvent); }));
        };
        try {
            for (var events_1 = __values(events), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {
                var event_1 = events_1_1.value;
                _loop_1(event_1);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (events_1_1 && !events_1_1.done && (_a = events_1.return)) _a.call(events_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * @param {?} events
     * @return {?}
     */
    EventService.prototype.removeEvents = /**
     * @param {?} events
     * @return {?}
     */
    function (events) {
        var e_2, _a;
        try {
            for (var events_2 = __values(events), events_2_1 = events_2.next(); !events_2_1.done; events_2_1 = events_2.next()) {
                var event_2 = events_2_1.value;
                if (event_2.dispose) {
                    event_2.dispose();
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (events_2_1 && !events_2_1.done && (_a = events_2.return)) _a.call(events_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    /** @nocollapse */
    EventService.ctorParameters = function () { return []; };
EventService.ɵfac = function EventService_Factory(t) { return new (t || EventService)(); };
EventService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: EventService, factory: function (t) { return EventService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EventService, [{
        type: Injectable
    }], function () { return []; }, null); })();
    return EventService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MatVideoComponent = /** @class */ (function () {
    function MatVideoComponent(renderer, evt) {
        this.renderer = renderer;
        this.evt = evt;
        this.src = null;
        this.title = null;
        this.autoplay = false;
        this.preload = true;
        this.loop = false;
        this.quality = true;
        this.fullscreen = true;
        this.playsinline = false;
        this.showFrameByFrame = false;
        this.fps = 29.97;
        this.download = false;
        this.color = "primary";
        this.spinner = "spin";
        this.poster = null;
        this.keyboard = true;
        this.overlay = null;
        this.muted = false;
        this.mutedChange = new EventEmitter();
        this.timeChange = new EventEmitter();
        this.playing = false;
        this.isFullscreen = false;
        this.videoLoaded = false;
        this.isMouseMoving = false;
        this.isMouseMovingTimeout = 2000;
    }
    Object.defineProperty(MatVideoComponent.prototype, "time", {
        get: /**
         * @return {?}
         */
        function () {
            return this.getVideoTag().currentTime;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            var _this = this;
            /** @type {?} */
            var video = this.getVideoTag();
            if (video && val) {
                if (val > video.duration) {
                    val = video.duration;
                }
                if (val < 0) {
                    val = 0;
                }
                if (val !== video.currentTime) {
                    video.currentTime = val;
                }
                if (this.lastTime !== video.currentTime) {
                    setTimeout((/**
                     * @return {?}
                     */
                    function () { return _this.timeChange.emit(video.currentTime); }), 0);
                    this.lastTime = video.currentTime;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MatVideoComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.events = [
            {
                element: this.video.nativeElement,
                name: "loadstart",
                callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return (_this.videoLoaded = false); }),
                dispose: null
            },
            {
                element: this.video.nativeElement,
                name: "loadedmetadata",
                callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return _this.evLoadedMetadata(event); }),
                dispose: null
            },
            {
                element: this.video.nativeElement,
                name: "error",
                callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return console.error("Unhandled Video Error", event); }),
                dispose: null
            },
            {
                element: this.video.nativeElement,
                name: "contextmenu",
                callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return event.preventDefault(); }),
                dispose: null
            },
            {
                element: this.video.nativeElement,
                name: "timeupdate",
                callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return _this.evTimeUpdate(event); }),
                dispose: null
            },
            {
                element: this.player.nativeElement,
                name: "mousemove",
                callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return _this.evMouseMove(event); }),
                dispose: null
            }
        ];
        this.video.nativeElement.onloadeddata = (/**
         * @return {?}
         */
        function () { return (_this.videoLoaded = true); });
        this.evt.addEvents(this.renderer, this.events);
        this.setVideoSrc(this.src);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    MatVideoComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.src) {
            this.setVideoSrc(this.src);
        }
    };
    /**
     * @return {?}
     */
    MatVideoComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.video.nativeElement.onloadeddata = null;
        this.evt.removeEvents(this.events);
    };
    /**
     * @return {?}
     */
    MatVideoComponent.prototype.load = /**
     * @return {?}
     */
    function () {
        if (this.video && this.video.nativeElement) {
            this.video.nativeElement.load();
        }
    };
    /**
     * @return {?}
     */
    MatVideoComponent.prototype.getVideoTag = /**
     * @return {?}
     */
    function () {
        return this.video && this.video.nativeElement ? ((/** @type {?} */ (this.video.nativeElement))) : null;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MatVideoComponent.prototype.evLoadedMetadata = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.videoWidth = this.video.nativeElement.videoWidth;
        this.videoHeight = this.video.nativeElement.videoHeight;
        this.videoLoaded = true;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MatVideoComponent.prototype.evMouseMove = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.isMouseMoving = true;
        clearTimeout(this.isMouseMovingTimer);
        this.isMouseMovingTimer = setTimeout((/**
         * @return {?}
         */
        function () {
            _this.isMouseMoving = false;
        }), this.isMouseMovingTimeout);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MatVideoComponent.prototype.evTimeUpdate = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.time = this.getVideoTag().currentTime;
    };
    /**
     * @param {?} activeClass
     * @param {?} inactiveClass
     * @return {?}
     */
    MatVideoComponent.prototype.getOverlayClass = /**
     * @param {?} activeClass
     * @param {?} inactiveClass
     * @return {?}
     */
    function (activeClass, inactiveClass) {
        if (this.overlay === null) {
            return !this.playing || this.isMouseMoving ? activeClass : inactiveClass;
        }
        else {
            return this.overlay ? activeClass : inactiveClass;
        }
    };
    /**
     * @private
     * @param {?} src
     * @return {?}
     */
    MatVideoComponent.prototype.setVideoSrc = /**
     * @private
     * @param {?} src
     * @return {?}
     */
    function (src) {
        if (this.srcObjectURL) {
            URL.revokeObjectURL(this.srcObjectURL);
            this.srcObjectURL = null;
        }
        if (!this.video || !this.video.nativeElement) {
            return;
        }
        if (!src) {
            this.video.nativeElement.src = null;
            if ("srcObject" in HTMLVideoElement.prototype) {
                this.video.nativeElement.srcObject = new MediaStream();
            }
        }
        else if (typeof src === "string") {
            this.video.nativeElement.src = src;
        }
        else if ("srcObject" in HTMLVideoElement.prototype) {
            this.video.nativeElement.srcObject = src;
        }
        else {
            this.srcObjectURL = URL.createObjectURL(src);
            this.video.nativeElement.src = this.srcObjectURL;
        }
        this.video.nativeElement.muted = this.muted;
    };
    /** @nocollapse */
    MatVideoComponent.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: EventService }
    ]; };
    MatVideoComponent.propDecorators = {
        player: [{ type: ViewChild, args: ["player", { static: false },] }],
        video: [{ type: ViewChild, args: ["video", { static: false },] }],
        src: [{ type: Input }],
        title: [{ type: Input }],
        autoplay: [{ type: Input }],
        preload: [{ type: Input }],
        loop: [{ type: Input }],
        quality: [{ type: Input }],
        fullscreen: [{ type: Input }],
        playsinline: [{ type: Input }],
        showFrameByFrame: [{ type: Input }],
        fps: [{ type: Input }],
        download: [{ type: Input }],
        color: [{ type: Input }],
        spinner: [{ type: Input }],
        poster: [{ type: Input }],
        keyboard: [{ type: Input }],
        overlay: [{ type: Input }],
        muted: [{ type: Input }],
        mutedChange: [{ type: Output }],
        timeChange: [{ type: Output }],
        time: [{ type: Input }]
    };
MatVideoComponent.ɵfac = function MatVideoComponent_Factory(t) { return new (t || MatVideoComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(EventService)); };
MatVideoComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatVideoComponent, selectors: [["mat-video"]], viewQuery: function MatVideoComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
        ɵngcc0.ɵɵviewQuery(_c1, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.player = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.video = _t.first);
    } }, inputs: { src: "src", title: "title", autoplay: "autoplay", preload: "preload", loop: "loop", quality: "quality", fullscreen: "fullscreen", playsinline: "playsinline", showFrameByFrame: "showFrameByFrame", fps: "fps", download: "download", color: "color", spinner: "spinner", poster: "poster", keyboard: "keyboard", overlay: "overlay", muted: "muted", time: "time" }, outputs: { mutedChange: "mutedChange", timeChange: "timeChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c3, decls: 10, vars: 10, consts: [[1, "videoplayer", 3, "ngClass"], ["player", ""], ["class", "header", 3, "ngClass", 4, "ngIf"], [1, "video", 3, "preload"], ["video", ""], ["class", "controls", 3, "ngClass", 4, "ngIf"], [3, "spinner", "video"], [1, "header", 3, "ngClass"], [1, "controls", 3, "ngClass"], [1, "progress"], [3, "color", "video"], [1, "menu"], [1, "left"], [3, "video", "keyboard", "playChanged"], [3, "video", "fps", 4, "ngIf"], [3, "muted", "color", "video", "keyboard", "mutedChanged"], [3, "video"], [1, "right"], [3, "video", 4, "ngIf"], [3, "title", "video", 4, "ngIf"], [3, "player", "keyboard", "fullscreenChanged", 4, "ngIf"], [3, "video", "fps"], [3, "title", "video"], [3, "player", "keyboard", "fullscreenChanged"]], template: function MatVideoComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c2);
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵtemplate(2, MatVideoComponent_div_2_Template, 2, 2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "video", 3, 4);
        ɵngcc0.ɵɵprojection(5);
        ɵngcc0.ɵɵprojection(6, 1);
        ɵngcc0.ɵɵtext(7, " This browser does not support HTML5 video. ");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(8, MatVideoComponent_div_8_Template, 13, 14, "div", 5);
        ɵngcc0.ɵɵelement(9, "mat-video-spinner", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        var _r2 = ɵngcc0.ɵɵreference(4);
        ɵngcc0.ɵɵproperty("ngClass", ctx.getOverlayClass("show-mouse", "hide-mouse"));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.title);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("preload", ctx.preload ? "auto" : "metadata");
        ɵngcc0.ɵɵattribute("autoplay", ctx.autoplay ? true : null)("poster", ctx.poster ? ctx.poster : null, ɵngcc0.ɵɵsanitizeUrl)("loop", ctx.loop ? ctx.loop : null)("playsinline", ctx.playsinline ? true : null);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.videoLoaded);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("spinner", ctx.spinner)("video", _r2);
    } }, directives: function () { return [ɵngcc1.NgClass, ɵngcc1.NgIf, MatVideoSpinnerComponent,
        MatSeekProgressControlComponent,
        MatPlayButtonComponent,
        MatVolumeControlComponent,
        MatTimeControlComponent,
        MatFrameByFrameControlComponent,
        MatQualityControlComponent,
        MatDownloadButtonComponent,
        MatFullscreenButtonComponent]; }, styles: [".videoplayer[_ngcontent-%COMP%]{font-family:Roboto,\"Helvetica Neue\",sans-serif;background-color:#000;position:relative;width:100%;height:100%}.header[_ngcontent-%COMP%]{color:#fff;display:flex;justify-content:center;align-items:center;position:absolute;left:0;top:0;padding:14px 0;width:100%;z-index:1;background-image:linear-gradient(to top,rgba(0,0,0,0),rgba(0,0,0,.65))}.video[_ngcontent-%COMP%]{display:block;width:100%;height:100%;z-index:0}.controls[_ngcontent-%COMP%]{color:#fff;position:absolute;left:0;bottom:0;width:100%;z-index:1;background-image:linear-gradient(to bottom,rgba(0,0,0,0),rgba(0,0,0,.65))}.controls[_ngcontent-%COMP%]   .progress[_ngcontent-%COMP%]{height:26px}.controls[_ngcontent-%COMP%]   .menu[_ngcontent-%COMP%]{display:flex;align-items:center;flex-direction:row;justify-content:space-between;height:48px}.controls[_ngcontent-%COMP%]   .menu[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]{justify-content:flex-start}.controls[_ngcontent-%COMP%]   .menu[_ngcontent-%COMP%]   .right[_ngcontent-%COMP%]{justify-content:flex-end}.visible[_ngcontent-%COMP%]{visibility:visible;opacity:1;transition:opacity .5s linear}.hidden[_ngcontent-%COMP%]{visibility:hidden;opacity:0;transition:visibility .5s,opacity .5s linear}.show-mouse[_ngcontent-%COMP%]{cursor:default}.hide-mouse[_ngcontent-%COMP%]{cursor:none}", "@font-face{font-family:\"Material Icons\";font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/materialicons/v36/flUhRq6tzZclQEJ-Vdg-IuiaDsNc.woff2) format(\"woff2\")} .material-icons{font-family:\"Material Icons\";font-weight:400;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;font-feature-settings:\"liga\";-webkit-font-feature-settings:\"liga\";-webkit-font-smoothing:antialiased}"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatVideoComponent, [{
        type: Component,
        args: [{
                selector: "mat-video",
                template: "<div #player class=\"videoplayer\" [ngClass]=\"getOverlayClass('show-mouse', 'hide-mouse')\">\n  <div class=\"header\" *ngIf=\"title\" [ngClass]=\"getOverlayClass('visible', 'hidden')\">\n    {{ title }}\n  </div>\n\n  <video\n    #video\n    class=\"video\"\n    [attr.autoplay]=\"autoplay ? true : null\"\n    [preload]=\"preload ? 'auto' : 'metadata'\"\n    [attr.poster]=\"poster ? poster : null\"\n    [attr.loop]=\"loop ? loop : null\"\n    [attr.playsinline]=\"playsinline ? true : null\"\n  >\n    <ng-content select=\"source\"></ng-content>\n    <ng-content select=\"track\"></ng-content>\n    This browser does not support HTML5 video.\n  </video>\n\n  <div class=\"controls\" *ngIf=\"videoLoaded\" [ngClass]=\"getOverlayClass('visible', 'hidden')\">\n    <div class=\"progress\">\n      <mat-seek-progress-control [color]=\"color\" [video]=\"video\"></mat-seek-progress-control>\n    </div>\n\n    <div class=\"menu\">\n      <div class=\"left\">\n        <mat-play-button (playChanged)=\"playing = $event\" [video]=\"video\" [keyboard]=\"keyboard\"> </mat-play-button>\n\n        <mat-frame-by-frame-control *ngIf=\"showFrameByFrame\" [video]=\"video\" [fps]=\"fps\"></mat-frame-by-frame-control>\n\n        <mat-volume-control\n          [muted]=\"muted\"\n          (mutedChanged)=\"muted = $event; mutedChange.emit(muted)\"\n          [color]=\"color\"\n          [video]=\"video\"\n          [keyboard]=\"keyboard\"\n        >\n        </mat-volume-control>\n\n        <mat-time-control [video]=\"video\"></mat-time-control>\n      </div>\n\n      <div class=\"right\">\n        <mat-quality-control *ngIf=\"quality\" [video]=\"video\"></mat-quality-control>\n\n        <mat-download-button *ngIf=\"download\" [title]=\"title\" [video]=\"video\"></mat-download-button>\n\n        <mat-fullscreen-button\n          *ngIf=\"fullscreen\"\n          (fullscreenChanged)=\"isFullscreen = $event\"\n          [player]=\"player\"\n          [keyboard]=\"keyboard\"\n        ></mat-fullscreen-button>\n      </div>\n    </div>\n  </div>\n\n  <mat-video-spinner [spinner]=\"spinner\" [video]=\"video\"></mat-video-spinner>\n</div>\n",
                styles: [".videoplayer{font-family:Roboto,\"Helvetica Neue\",sans-serif;background-color:#000;position:relative;width:100%;height:100%}.header{color:#fff;display:flex;justify-content:center;align-items:center;position:absolute;left:0;top:0;padding:14px 0;width:100%;z-index:1;background-image:linear-gradient(to top,rgba(0,0,0,0),rgba(0,0,0,.65))}.video{display:block;width:100%;height:100%;z-index:0}.controls{color:#fff;position:absolute;left:0;bottom:0;width:100%;z-index:1;background-image:linear-gradient(to bottom,rgba(0,0,0,0),rgba(0,0,0,.65))}.controls .progress{height:26px}.controls .menu{display:flex;align-items:center;flex-direction:row;justify-content:space-between;height:48px}.controls .menu .left{justify-content:flex-start}.controls .menu .right{justify-content:flex-end}.visible{visibility:visible;opacity:1;transition:opacity .5s linear}.hidden{visibility:hidden;opacity:0;transition:visibility .5s,opacity .5s linear}.show-mouse{cursor:default}.hide-mouse{cursor:none}", "@font-face{font-family:\"Material Icons\";font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/materialicons/v36/flUhRq6tzZclQEJ-Vdg-IuiaDsNc.woff2) format(\"woff2\")}::ng-deep.material-icons{font-family:\"Material Icons\";font-weight:400;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;font-feature-settings:\"liga\";-webkit-font-feature-settings:\"liga\";-webkit-font-smoothing:antialiased}"]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: EventService }]; }, { src: [{
            type: Input
        }], title: [{
            type: Input
        }], autoplay: [{
            type: Input
        }], preload: [{
            type: Input
        }], loop: [{
            type: Input
        }], quality: [{
            type: Input
        }], fullscreen: [{
            type: Input
        }], playsinline: [{
            type: Input
        }], showFrameByFrame: [{
            type: Input
        }], fps: [{
            type: Input
        }], download: [{
            type: Input
        }], color: [{
            type: Input
        }], spinner: [{
            type: Input
        }], poster: [{
            type: Input
        }], keyboard: [{
            type: Input
        }], overlay: [{
            type: Input
        }], muted: [{
            type: Input
        }], mutedChange: [{
            type: Output
        }], timeChange: [{
            type: Output
        }], time: [{
            type: Input
        }], player: [{
            type: ViewChild,
            args: ["player", { static: false }]
        }], video: [{
            type: ViewChild,
            args: ["video", { static: false }]
        }] }); })();
    return MatVideoComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MatVideoSourceDirective = /** @class */ (function () {
    function MatVideoSourceDirective(matVideoComponent, el) {
        this.matVideoComponent = matVideoComponent;
        this.el = el;
        this.src = null;
        this.type = null;
        this.init = true;
        this.video = matVideoComponent;
        this.source = el.nativeElement;
        this.init = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    MatVideoSourceDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        this.source.src = this.src;
        this.source.type = this.type;
        if (!this.init) {
            this.video.load();
        }
    };
    /** @nocollapse */
    MatVideoSourceDirective.ctorParameters = function () { return [
        { type: MatVideoComponent, decorators: [{ type: Host }] },
        { type: ElementRef }
    ]; };
    MatVideoSourceDirective.propDecorators = {
        src: [{ type: Input }],
        type: [{ type: Input }]
    };
MatVideoSourceDirective.ɵfac = function MatVideoSourceDirective_Factory(t) { return new (t || MatVideoSourceDirective)(ɵngcc0.ɵɵdirectiveInject(MatVideoComponent, 1), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
MatVideoSourceDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatVideoSourceDirective, selectors: [["", "matVideoSource", ""]], inputs: { src: "src", type: "type" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatVideoSourceDirective, [{
        type: Directive,
        args: [{
                selector: "[matVideoSource]"
            }]
    }], function () { return [{ type: MatVideoComponent, decorators: [{
                type: Host
            }] }, { type: ɵngcc0.ElementRef }]; }, { src: [{
            type: Input
        }], type: [{
            type: Input
        }] }); })();
    return MatVideoSourceDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MatVideoTrackDirective = /** @class */ (function () {
    function MatVideoTrackDirective(matVideoComponent, el) {
        this.matVideoComponent = matVideoComponent;
        this.el = el;
        this.src = null;
        this.kind = null;
        this.srclang = null;
        this.label = null;
        this.init = true;
        this.video = matVideoComponent;
        this.track = el.nativeElement;
        this.init = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    MatVideoTrackDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        this.track.src = this.src;
        this.track.kind = this.kind;
        this.track.srclang = this.srclang;
        this.track.label = this.label;
        if (!this.init) {
            this.video.load();
        }
    };
    /** @nocollapse */
    MatVideoTrackDirective.ctorParameters = function () { return [
        { type: MatVideoComponent, decorators: [{ type: Host }] },
        { type: ElementRef }
    ]; };
    MatVideoTrackDirective.propDecorators = {
        src: [{ type: Input }],
        kind: [{ type: Input }],
        srclang: [{ type: Input }],
        label: [{ type: Input }]
    };
MatVideoTrackDirective.ɵfac = function MatVideoTrackDirective_Factory(t) { return new (t || MatVideoTrackDirective)(ɵngcc0.ɵɵdirectiveInject(MatVideoComponent, 1), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
MatVideoTrackDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatVideoTrackDirective, selectors: [["", "matVideoTrack", ""]], inputs: { src: "src", kind: "kind", srclang: "srclang", label: "label" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatVideoTrackDirective, [{
        type: Directive,
        args: [{
                selector: "[matVideoTrack]"
            }]
    }], function () { return [{ type: MatVideoComponent, decorators: [{
                type: Host
            }] }, { type: ɵngcc0.ElementRef }]; }, { src: [{
            type: Input
        }], kind: [{
            type: Input
        }], srclang: [{
            type: Input
        }], label: [{
            type: Input
        }] }); })();
    return MatVideoTrackDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Counter used to generate unique IDs for progress bars.
 * @type {?}
 */
var sliderprogressbarId = 0;
var MatSliderProgressBarComponent = /** @class */ (function (_super) {
    __extends(MatSliderProgressBarComponent, _super);
    function MatSliderProgressBarComponent(elementRef, focusMonitor, changeDetectorRef, dir, tabIndex) {
        var _this = _super.call(this, elementRef, focusMonitor, changeDetectorRef, dir, tabIndex) || this;
        _this.mode = "buffer";
        _this.value = 0;
        _this.pBufferValue = 0;
        /**
         * The id of the progress bar.
         */
        _this.sliderprogressbarId = "mat-slider-progress-bar-" + sliderprogressbarId++;
        _this.tabIndex = parseInt(tabIndex, 10) || 0;
        return _this;
    }
    Object.defineProperty(MatSliderProgressBarComponent.prototype, "bufferValue", {
        /** Buffer value of the progress bar. Defaults to zero. */
        get: /**
         * Buffer value of the progress bar. Defaults to zero.
         * @return {?}
         */
        function () {
            return this.pBufferValue;
        },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            this.pBufferValue = clamp(v || 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatSliderProgressBarComponent.prototype, "_trackBufferStyles", {
        /** CSS styles for the track fill element. */
        get: /**
         * CSS styles for the track fill element.
         * @return {?}
         */
        function () {
            if (this.mode === "buffer") {
                /** @type {?} */
                var axis = this.vertical ? "Y" : "X";
                return {
                    transform: "translate" + axis + "(0px) scale" + axis + "(" + this.pBufferValue / 100 + ")"
                };
            }
        },
        enumerable: true,
        configurable: true
    });
    /** @nocollapse */
    MatSliderProgressBarComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: FocusMonitor },
        { type: ChangeDetectorRef },
        { type: Directionality, decorators: [{ type: Optional }] },
        { type: String, decorators: [{ type: Attribute, args: ["tabindex",] }] }
    ]; };
    MatSliderProgressBarComponent.propDecorators = {
        mode: [{ type: Input }],
        value: [{ type: Input }],
        bufferValue: [{ type: Input }]
    };
MatSliderProgressBarComponent.ɵfac = function MatSliderProgressBarComponent_Factory(t) { return new (t || MatSliderProgressBarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FocusMonitor), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Directionality, 8), ɵngcc0.ɵɵinjectAttribute("tabindex")); };
MatSliderProgressBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatSliderProgressBarComponent, selectors: [["mat-slider-progress-bar"]], hostAttrs: ["role", "slider", 1, "mat-slider"], hostVars: 24, hostBindings: function MatSliderProgressBarComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focus", function MatSliderProgressBarComponent_focus_HostBindingHandler() { return ctx._onFocus(); })("blur", function MatSliderProgressBarComponent_blur_HostBindingHandler() { return ctx._onBlur(); })("click", function MatSliderProgressBarComponent_click_HostBindingHandler($event) { return ctx["_onClick"] ? ctx["_onClick"]($event) : null; })("mousedown", function MatSliderProgressBarComponent_mousedown_HostBindingHandler($event) { return ctx["_onMousedown"] ? ctx["_onMousedown"]($event) : null; })("keydown", function MatSliderProgressBarComponent_keydown_HostBindingHandler($event) { return ctx._onKeydown($event); })("keyup", function MatSliderProgressBarComponent_keyup_HostBindingHandler() { return ctx._onKeyup(); })("mouseenter", function MatSliderProgressBarComponent_mouseenter_HostBindingHandler() { return ctx._onMouseenter(); })("slide", function MatSliderProgressBarComponent_slide_HostBindingHandler($event) { return ctx._onSlide($event); })("slideend", function MatSliderProgressBarComponent_slideend_HostBindingHandler() { return ctx._onSlideEnd(); })("slidestart", function MatSliderProgressBarComponent_slidestart_HostBindingHandler($event) { return ctx._onSlideStart($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("tabIndex", ctx.tabIndex);
        ɵngcc0.ɵɵattribute("aria-disabled", ctx.disabled)("aria-valuemax", ctx.max)("aria-valuemin", ctx.min)("aria-valuenow", ctx.value)("aria-orientation", ctx.vertical ? "vertical" : "horizontal");
        ɵngcc0.ɵɵclassProp("mat-slider-disabled", ctx.disabled)("mat-slider-has-ticks", ctx.tickInterval)("mat-slider-horizontal", !ctx.vertical)("mat-slider-axis-inverted", ctx._invertAxis)("mat-slider-sliding", ctx._isSliding)("mat-slider-thumb-label-showing", ctx.thumbLabel)("mat-slider-vertical", ctx.vertical)("mat-slider-min-value", ctx._isMinValue)("mat-slider-hide-last-tick", ctx.disabled || ctx._isMinValue && ctx._thumbGap && ctx._invertAxis);
    } }, inputs: { disabled: "disabled", color: "color", tabIndex: "tabIndex", bufferValue: "bufferValue", mode: "mode", value: "value" }, features: [ɵngcc0.ɵɵProvidersFeature([MAT_SLIDER_VALUE_ACCESSOR]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 18, vars: 8, consts: [[1, "mat-slider-wrapper"], ["sliderWrapper", ""], [1, "mat-slider-track-wrapper"], ["width", "100%", "height", "2", "focusable", "false", 1, "mat-slider-progress-background"], ["x", "2.5", "y", "0", "width", "5", "height", "2.5", "patternUnits", "userSpaceOnUse", 3, "id"], ["cx", "1.25", "cy", "1.25", "r", "1.25"], ["width", "100%", "height", "100%"], [1, "mat-slider-track-fill", "mat-slider-track-buffer", 3, "ngStyle"], [1, "mat-slider-track-fill", 3, "ngStyle"], [1, "mat-slider-ticks-container", 3, "ngStyle"], [1, "mat-slider-ticks", 3, "ngStyle"], [1, "mat-slider-thumb-container", 3, "ngStyle"], [1, "mat-slider-focus-ring"], [1, "mat-slider-thumb"], [1, "mat-slider-thumb-label"], [1, "mat-slider-thumb-label-text"]], template: function MatSliderProgressBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(3, "svg", 3);
        ɵngcc0.ɵɵelementStart(4, "defs");
        ɵngcc0.ɵɵelementStart(5, "pattern", 4);
        ɵngcc0.ɵɵelement(6, "circle", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(7, "rect", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelement(8, "div", 7);
        ɵngcc0.ɵɵelement(9, "div", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(10, "div", 9);
        ɵngcc0.ɵɵelement(11, "div", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(12, "div", 11);
        ɵngcc0.ɵɵelement(13, "div", 12);
        ɵngcc0.ɵɵelement(14, "div", 13);
        ɵngcc0.ɵɵelementStart(15, "div", 14);
        ɵngcc0.ɵɵelementStart(16, "span", 15);
        ɵngcc0.ɵɵtext(17);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("id", ctx.sliderprogressbarId);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("fill", "url(#" + ctx.sliderprogressbarId + ")");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx._trackBufferStyles);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx._trackFillStyles);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx._ticksContainerStyles);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx._ticksStyles);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx._thumbContainerStyles);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵtextInterpolate(ctx.displayValue);
    } }, directives: [ɵngcc1.NgStyle], styles: ["[_nghost-%COMP%]{width:100%}.mat-slider-progress-background[_ngcontent-%COMP%]{position:absolute;height:2px;width:100%;fill:#d3d3d3}.mat-slider-track-buffer[_ngcontent-%COMP%]{background-color:#d3d3d3!important}.mat-slider-thumb[_ngcontent-%COMP%]{border-color:transparent!important;visibility:hidden;opacity:0;transition:visibility .2s,opacity .2s linear}[_nghost-%COMP%]:hover   .mat-slider-thumb[_ngcontent-%COMP%]{visibility:visible;opacity:1;transition:opacity .2s linear}"], changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatSliderProgressBarComponent, [{
        type: Component,
        args: [{
                selector: "mat-slider-progress-bar",
                template: "<div class=\"mat-slider-wrapper\" #sliderWrapper>\r\n  <div class=\"mat-slider-track-wrapper\">\r\n    <svg width=\"100%\" height=\"2\" focusable=\"false\" class=\"mat-slider-progress-background\">\r\n      <defs>\r\n        <pattern [id]=\"sliderprogressbarId\" x=\"2.5\" y=\"0\" width=\"5\" height=\"2.5\" patternUnits=\"userSpaceOnUse\">\r\n          <circle cx=\"1.25\" cy=\"1.25\" r=\"1.25\" />\r\n        </pattern>\r\n      </defs>\r\n      <rect [attr.fill]=\"'url(#' + sliderprogressbarId + ')'\" width=\"100%\" height=\"100%\" />\r\n    </svg>\r\n    <div class=\"mat-slider-track-fill mat-slider-track-buffer\" [ngStyle]=\"_trackBufferStyles\"></div>\r\n    <div class=\"mat-slider-track-fill\" [ngStyle]=\"_trackFillStyles\"></div>\r\n  </div>\r\n  <div class=\"mat-slider-ticks-container\" [ngStyle]=\"_ticksContainerStyles\">\r\n    <div class=\"mat-slider-ticks\" [ngStyle]=\"_ticksStyles\"></div>\r\n  </div>\r\n  <div class=\"mat-slider-thumb-container\" [ngStyle]=\"_thumbContainerStyles\">\r\n    <div class=\"mat-slider-focus-ring\"></div>\r\n    <div class=\"mat-slider-thumb\"></div>\r\n    <div class=\"mat-slider-thumb-label\">\r\n      <span class=\"mat-slider-thumb-label-text\">{{ displayValue }}</span>\r\n    </div>\r\n  </div>\r\n</div>\r\n",
                providers: [MAT_SLIDER_VALUE_ACCESSOR],
                host: {
                    "(focus)": "_onFocus()",
                    "(blur)": "_onBlur()",
                    "(click)": 'this["_onClick"] ? this["_onClick"]($event) : null',
                    // Angular 5/6 support
                    "(mousedown)": 'this["_onMousedown"] ? this["_onMousedown"]($event) : null',
                    // Angular 7 support
                    "(keydown)": "_onKeydown($event)",
                    "(keyup)": "_onKeyup()",
                    "(mouseenter)": "_onMouseenter()",
                    "(slide)": "_onSlide($event)",
                    "(slideend)": "_onSlideEnd()",
                    "(slidestart)": "_onSlideStart($event)",
                    class: "mat-slider",
                    role: "slider",
                    "[tabIndex]": "tabIndex",
                    "[attr.aria-disabled]": "disabled",
                    "[attr.aria-valuemax]": "max",
                    "[attr.aria-valuemin]": "min",
                    "[attr.aria-valuenow]": "value",
                    "[attr.aria-orientation]": 'vertical ? "vertical" : "horizontal"',
                    "[class.mat-slider-disabled]": "disabled",
                    "[class.mat-slider-has-ticks]": "tickInterval",
                    "[class.mat-slider-horizontal]": "!vertical",
                    "[class.mat-slider-axis-inverted]": "_invertAxis",
                    "[class.mat-slider-sliding]": "_isSliding",
                    "[class.mat-slider-thumb-label-showing]": "thumbLabel",
                    "[class.mat-slider-vertical]": "vertical",
                    "[class.mat-slider-min-value]": "_isMinValue",
                    "[class.mat-slider-hide-last-tick]": "disabled || _isMinValue && _thumbGap && _invertAxis"
                },
                inputs: ["disabled", "color", "tabIndex"],
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{width:100%}.mat-slider-progress-background{position:absolute;height:2px;width:100%;fill:#d3d3d3}.mat-slider-track-buffer{background-color:#d3d3d3!important}.mat-slider-thumb{border-color:transparent!important;visibility:hidden;opacity:0;transition:visibility .2s,opacity .2s linear}:host:hover .mat-slider-thumb{visibility:visible;opacity:1;transition:opacity .2s linear}"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc2.FocusMonitor }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc3.Directionality, decorators: [{
                type: Optional
            }] }, { type: String, decorators: [{
                type: Attribute,
                args: ["tabindex"]
            }] }]; }, { bufferValue: [{
            type: Input
        }], mode: [{
            type: Input
        }], value: [{
            type: Input
        }] }); })();
    return MatSliderProgressBarComponent;
}(MatSlider));
/**
 * Clamps a value to be between two numbers, by default 0 and 100.
 * @param {?} v
 * @param {?=} min
 * @param {?=} max
 * @return {?}
 */
function clamp(v, min, max) {
    if (min === void 0) { min = 0; }
    if (max === void 0) { max = 100; }
    return Math.max(min, Math.min(max, v));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SecondsToTimePipe = /** @class */ (function () {
    function SecondsToTimePipe() {
        this.times = {
            year: 31557600,
            month: 2629746,
            day: 86400,
            hour: 3600
        };
    }
    /**
     * @param {?} seconds
     * @return {?}
     */
    SecondsToTimePipe.prototype.transform = /**
     * @param {?} seconds
     * @return {?}
     */
    function (seconds) {
        if (!seconds) {
            return "0:00";
        }
        else {
            /** @type {?} */
            var timeString = "";
            for (var key in this.times) {
                if (Math.floor(seconds / this.times[key]) > 0) {
                    timeString += Math.floor(seconds / this.times[key]).toString() + ":";
                    seconds = seconds - this.times[key] * Math.floor(seconds / this.times[key]);
                }
            }
            timeString += Math.floor(seconds / 60).toString() + ":";
            seconds = seconds - 60 * Math.floor(seconds / 60);
            if (Math.floor(seconds) < 10) {
                timeString += "0";
            }
            timeString += Math.floor(seconds).toString();
            return timeString;
        }
    };
SecondsToTimePipe.ɵfac = function SecondsToTimePipe_Factory(t) { return new (t || SecondsToTimePipe)(); };
SecondsToTimePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "secondsToTime", type: SecondsToTimePipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SecondsToTimePipe, [{
        type: Pipe,
        args: [{
                name: "secondsToTime"
            }]
    }], function () { return []; }, null); })();
    return SecondsToTimePipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FullscreenService = /** @class */ (function () {
    function FullscreenService() {
        this.fnMap = [
            // Object keys
            ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"],
            // New WebKit
            [
                "webkitRequestFullscreen",
                "webkitExitFullscreen",
                "webkitFullscreenElement",
                "webkitFullscreenEnabled",
                "webkitfullscreenchange",
                "webkitfullscreenerror"
            ],
            // Old WebKit (Safari 5.1)
            [
                "webkitRequestFullScreen",
                "webkitCancelFullScreen",
                "webkitCurrentFullScreenElement",
                "webkitCancelFullScreen",
                "webkitfullscreenchange",
                "webkitfullscreenerror"
            ],
            // Mozilla
            [
                "mozRequestFullScreen",
                "mozCancelFullScreen",
                "mozFullScreenElement",
                "mozFullScreenEnabled",
                "mozfullscreenchange",
                "mozfullscreenerror"
            ],
            // MS
            ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]
        ];
        this.keyboardAllowed = typeof Element !== "undefined" && "ALLOW_KEYBOARD_INPUT" in Element;
        /** @type {?} */
        var ret = {};
        /** @type {?} */
        var val;
        for (var i = 0; i < this.fnMap.length; i++) {
            val = this.fnMap[i];
            if (val && val[1] in document) {
                for (i = 0; i < val.length; i++) {
                    // Map everything to the first list of keys
                    ret[this.fnMap[0][i].toString()] = val[i];
                }
                this.fn = ret;
            }
        }
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    FullscreenService.prototype.request = /**
     * @param {?} elem
     * @return {?}
     */
    function (elem) {
        /** @type {?} */
        var request = this.fn.requestFullscreen;
        elem = elem || document.documentElement;
        // Work around Safari 5.1 bug: reports support for
        // keyboard in fullscreen even though it doesn't.
        // Browser sniffing, since the alternative with
        // setTimeout is even worse.
        if (/5\.1[.\d]* Safari/.test(navigator.userAgent)) {
            elem[request]();
        }
        else {
            elem[request](this.keyboardAllowed ? ((/** @type {?} */ (Element))).ALLOW_KEYBOARD_INPUT : {});
        }
    };
    /**
     * @return {?}
     */
    FullscreenService.prototype.exit = /**
     * @return {?}
     */
    function () {
        document[this.fn.exitFullscreen]();
    };
    /**
     * @param {?} elem
     * @return {?}
     */
    FullscreenService.prototype.toggle = /**
     * @param {?} elem
     * @return {?}
     */
    function (elem) {
        if (this.isFullscreen()) {
            this.exit();
        }
        else {
            this.request(elem);
        }
    };
    /**
     * @param {?} callback
     * @return {?}
     */
    FullscreenService.prototype.onChange = /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        document.addEventListener(this.fn.fullscreenchange, callback, false);
    };
    /**
     * @param {?} callback
     * @return {?}
     */
    FullscreenService.prototype.onError = /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        document.addEventListener(this.fn.fullscreenerror, callback, false);
    };
    /**
     * @return {?}
     */
    FullscreenService.prototype.isFullscreen = /**
     * @return {?}
     */
    function () {
        return Boolean(document[this.fn.fullscreenElement]);
    };
    /**
     * @return {?}
     */
    FullscreenService.prototype.isEnabled = /**
     * @return {?}
     */
    function () {
        // Coerce to boolean in case of old WebKit
        return Boolean(document[this.fn.fullscreenEnabled]);
    };
    /**
     * @return {?}
     */
    FullscreenService.prototype.getElement = /**
     * @return {?}
     */
    function () {
        return document[this.fn.fullscreenElement];
    };
    /** @nocollapse */
    FullscreenService.ctorParameters = function () { return []; };
FullscreenService.ɵfac = function FullscreenService_Factory(t) { return new (t || FullscreenService)(); };
FullscreenService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: FullscreenService, factory: function (t) { return FullscreenService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FullscreenService, [{
        type: Injectable
    }], function () { return []; }, null); })();
    return FullscreenService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MatDownloadButtonComponent = /** @class */ (function () {
    function MatDownloadButtonComponent() {
    }
    /** @nocollapse */
    MatDownloadButtonComponent.ctorParameters = function () { return []; };
    MatDownloadButtonComponent.propDecorators = {
        video: [{ type: Input }],
        title: [{ type: Input }]
    };
MatDownloadButtonComponent.ɵfac = function MatDownloadButtonComponent_Factory(t) { return new (t || MatDownloadButtonComponent)(); };
MatDownloadButtonComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatDownloadButtonComponent, selectors: [["mat-download-button"]], inputs: { video: "video", title: "title" }, decls: 3, vars: 2, consts: [["mat-icon-button", "", 3, "href", "download"]], template: function MatDownloadButtonComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "a", 0);
        ɵngcc0.ɵɵelementStart(1, "mat-icon");
        ɵngcc0.ɵɵtext(2, "file_download");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("href", ctx.video == null ? null : ctx.video.currentSrc, ɵngcc0.ɵɵsanitizeUrl)("download", ctx.title);
    } }, directives: [ɵngcc4.MatAnchor, ɵngcc5.MatIcon], styles: ["a[_ngcontent-%COMP%]{color:inherit;text-decoration:none}"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatDownloadButtonComponent, [{
        type: Component,
        args: [{
                selector: "mat-download-button",
                template: "<a mat-icon-button [href]=\"video?.currentSrc\" [download]=\"title\">\r\n  <mat-icon>file_download</mat-icon>\r\n</a>\r\n",
                styles: ["a{color:inherit;text-decoration:none}"]
            }]
    }], function () { return []; }, { video: [{
            type: Input
        }], title: [{
            type: Input
        }] }); })();
    return MatDownloadButtonComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MatFrameByFrameControlComponent = /** @class */ (function () {
    function MatFrameByFrameControlComponent() {
        this.fps = 29.97;
    }
    /**
     * @return {?}
     */
    MatFrameByFrameControlComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () { };
    /**
     * @param {?} nbFrames
     * @return {?}
     */
    MatFrameByFrameControlComponent.prototype.seekFrames = /**
     * @param {?} nbFrames
     * @return {?}
     */
    function (nbFrames) {
        if (!this.video.paused) {
            this.video.pause();
        }
        /** @type {?} */
        var currentFrames = this.video.currentTime * this.fps;
        /** @type {?} */
        var newPos = (currentFrames + nbFrames) / this.fps + 0.00001;
        this.video.currentTime = newPos;
    };
    /** @nocollapse */
    MatFrameByFrameControlComponent.ctorParameters = function () { return []; };
    MatFrameByFrameControlComponent.propDecorators = {
        video: [{ type: Input }],
        fps: [{ type: Input }]
    };
MatFrameByFrameControlComponent.ɵfac = function MatFrameByFrameControlComponent_Factory(t) { return new (t || MatFrameByFrameControlComponent)(); };
MatFrameByFrameControlComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatFrameByFrameControlComponent, selectors: [["mat-frame-by-frame-control"]], inputs: { fps: "fps", video: "video" }, decls: 12, vars: 0, consts: [["mat-icon-button", "", 3, "click"]], template: function MatFrameByFrameControlComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function MatFrameByFrameControlComponent_Template_button_click_0_listener() { return ctx.seekFrames(0 - 5); });
        ɵngcc0.ɵɵelementStart(1, "mat-icon");
        ɵngcc0.ɵɵtext(2, "skip_previous");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "button", 0);
        ɵngcc0.ɵɵlistener("click", function MatFrameByFrameControlComponent_Template_button_click_3_listener() { return ctx.seekFrames(0 - 1); });
        ɵngcc0.ɵɵelementStart(4, "mat-icon");
        ɵngcc0.ɵɵtext(5, "arrow_left");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "button", 0);
        ɵngcc0.ɵɵlistener("click", function MatFrameByFrameControlComponent_Template_button_click_6_listener() { return ctx.seekFrames(1); });
        ɵngcc0.ɵɵelementStart(7, "mat-icon");
        ɵngcc0.ɵɵtext(8, "arrow_right");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(9, "button", 0);
        ɵngcc0.ɵɵlistener("click", function MatFrameByFrameControlComponent_Template_button_click_9_listener() { return ctx.seekFrames(5); });
        ɵngcc0.ɵɵelementStart(10, "mat-icon");
        ɵngcc0.ɵɵtext(11, "skip_next");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } }, directives: [ɵngcc4.MatButton, ɵngcc5.MatIcon], styles: [""] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatFrameByFrameControlComponent, [{
        type: Component,
        args: [{
                selector: "mat-frame-by-frame-control",
                template: "<button mat-icon-button (click)=\"seekFrames(-5)\">\r\n  <mat-icon>skip_previous</mat-icon>\r\n</button>\r\n\r\n<button mat-icon-button (click)=\"seekFrames(-1)\">\r\n  <mat-icon>arrow_left</mat-icon>\r\n</button>\r\n\r\n<button mat-icon-button (click)=\"seekFrames(1)\">\r\n  <mat-icon>arrow_right</mat-icon>\r\n</button>\r\n\r\n<button mat-icon-button (click)=\"seekFrames(5)\">\r\n  <mat-icon>skip_next</mat-icon>\r\n</button>\r\n",
                styles: [""]
            }]
    }], function () { return []; }, { fps: [{
            type: Input
        }], video: [{
            type: Input
        }] }); })();
    return MatFrameByFrameControlComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MatFullscreenButtonComponent = /** @class */ (function () {
    function MatFullscreenButtonComponent(fscreen, evt) {
        this.fscreen = fscreen;
        this.evt = evt;
        this.canFullscreen = false;
        this.fullscreen = false;
        this.fullscreenChanged = new EventEmitter();
        this.keyboard = true;
    }
    /**
     * @return {?}
     */
    MatFullscreenButtonComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.fscreen.isEnabled()) {
            this.canFullscreen = true;
        }
        this.fscreen.onChange((/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return (_this.fscreen.isFullscreen() ? _this.onChangesFullscreen(true) : _this.onChangesFullscreen(false)); }));
    };
    /**
     * @param {?} value
     * @return {?}
     */
    MatFullscreenButtonComponent.prototype.setFullscreen = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.canFullscreen && this.fullscreen !== value) {
            this.toggleFullscreen();
        }
    };
    /**
     * @return {?}
     */
    MatFullscreenButtonComponent.prototype.toggleFullscreen = /**
     * @return {?}
     */
    function () {
        this.fullscreen = !this.fullscreen;
        this.updateFullscreen();
    };
    /**
     * @return {?}
     */
    MatFullscreenButtonComponent.prototype.updateFullscreen = /**
     * @return {?}
     */
    function () {
        this.fullscreen ? this.fscreen.request(this.player) : this.fscreen.exit();
        this.fullscreenChanged.emit(this.fullscreen);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    MatFullscreenButtonComponent.prototype.onChangesFullscreen = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.fullscreen = value;
        this.fullscreenChanged.emit(this.fullscreen);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MatFullscreenButtonComponent.prototype.onFullscreenKey = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.keyboard) {
            this.toggleFullscreen();
            event.preventDefault();
        }
    };
    /** @nocollapse */
    MatFullscreenButtonComponent.ctorParameters = function () { return [
        { type: FullscreenService },
        { type: EventService }
    ]; };
    MatFullscreenButtonComponent.propDecorators = {
        player: [{ type: Input }],
        fullscreen: [{ type: Input }],
        fullscreenChanged: [{ type: Output }],
        keyboard: [{ type: Input }],
        onFullscreenKey: [{ type: HostListener, args: ["document:keyup.f", ["$event"],] }]
    };
MatFullscreenButtonComponent.ɵfac = function MatFullscreenButtonComponent_Factory(t) { return new (t || MatFullscreenButtonComponent)(ɵngcc0.ɵɵdirectiveInject(FullscreenService), ɵngcc0.ɵɵdirectiveInject(EventService)); };
MatFullscreenButtonComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatFullscreenButtonComponent, selectors: [["mat-fullscreen-button"]], hostBindings: function MatFullscreenButtonComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keyup.f", function MatFullscreenButtonComponent_keyup_f_HostBindingHandler($event) { return ctx.onFullscreenKey($event); }, false, ɵngcc0.ɵɵresolveDocument);
    } }, inputs: { fullscreen: "fullscreen", keyboard: "keyboard", player: "player" }, outputs: { fullscreenChanged: "fullscreenChanged" }, decls: 3, vars: 3, consts: [["mat-icon-button", "", 3, "disabled", "click"], [4, "ngIf"]], template: function MatFullscreenButtonComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function MatFullscreenButtonComponent_Template_button_click_0_listener() { return ctx.toggleFullscreen(); });
        ɵngcc0.ɵɵtemplate(1, MatFullscreenButtonComponent_mat_icon_1_Template, 2, 0, "mat-icon", 1);
        ɵngcc0.ɵɵtemplate(2, MatFullscreenButtonComponent_mat_icon_2_Template, 2, 0, "mat-icon", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("disabled", !ctx.canFullscreen);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.fullscreen);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.fullscreen);
    } }, directives: [ɵngcc4.MatButton, ɵngcc1.NgIf, ɵngcc5.MatIcon], styles: [""] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatFullscreenButtonComponent, [{
        type: Component,
        args: [{
                selector: "mat-fullscreen-button",
                template: "<button mat-icon-button [disabled]=\"!canFullscreen\" (click)=\"toggleFullscreen()\">\r\n  <mat-icon *ngIf=\"!fullscreen\">fullscreen</mat-icon>\r\n  <mat-icon *ngIf=\"fullscreen\">fullscreen_exit</mat-icon>\r\n</button>\r\n",
                styles: [""]
            }]
    }], function () { return [{ type: FullscreenService }, { type: EventService }]; }, { fullscreen: [{
            type: Input
        }], fullscreenChanged: [{
            type: Output
        }], keyboard: [{
            type: Input
        }], onFullscreenKey: [{
            type: HostListener,
            args: ["document:keyup.f", ["$event"]]
        }], player: [{
            type: Input
        }] }); })();
    return MatFullscreenButtonComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MatPlayButtonComponent = /** @class */ (function () {
    function MatPlayButtonComponent(renderer, evt) {
        this.renderer = renderer;
        this.evt = evt;
        this.play = false;
        this.playChanged = new EventEmitter();
        this.keyboard = true;
    }
    /**
     * @return {?}
     */
    MatPlayButtonComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.events = [
            { element: this.video, name: "play", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return _this.setVideoPlayback(true); }), dispose: null },
            { element: this.video, name: "pause", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return _this.setVideoPlayback(false); }), dispose: null },
            { element: this.video, name: "durationchange", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return _this.setVideoPlayback(false); }), dispose: null },
            { element: this.video, name: "ended", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return _this.setVideoPlayback(false); }), dispose: null },
            { element: this.video, name: "click", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return _this.toggleVideoPlayback(); }), dispose: null }
        ];
        this.evt.addEvents(this.renderer, this.events);
    };
    /**
     * @return {?}
     */
    MatPlayButtonComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.evt.removeEvents(this.events);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    MatPlayButtonComponent.prototype.setVideoPlayback = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.play !== value) {
            this.toggleVideoPlayback();
        }
    };
    /**
     * @return {?}
     */
    MatPlayButtonComponent.prototype.toggleVideoPlayback = /**
     * @return {?}
     */
    function () {
        this.play = !this.play;
        this.updateVideoPlayback();
    };
    /**
     * @return {?}
     */
    MatPlayButtonComponent.prototype.updateVideoPlayback = /**
     * @return {?}
     */
    function () {
        this.play ? this.video.play() : this.video.pause();
        this.playChanged.emit(this.play);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MatPlayButtonComponent.prototype.onPlayKey = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.keyboard) {
            this.toggleVideoPlayback();
            event.preventDefault();
        }
    };
    /** @nocollapse */
    MatPlayButtonComponent.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: EventService }
    ]; };
    MatPlayButtonComponent.propDecorators = {
        video: [{ type: Input }],
        play: [{ type: Input }],
        playChanged: [{ type: Output }],
        keyboard: [{ type: Input }],
        onPlayKey: [{ type: HostListener, args: ["document:keyup.space", ["$event"],] }]
    };
MatPlayButtonComponent.ɵfac = function MatPlayButtonComponent_Factory(t) { return new (t || MatPlayButtonComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(EventService)); };
MatPlayButtonComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatPlayButtonComponent, selectors: [["mat-play-button"]], hostBindings: function MatPlayButtonComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keyup.space", function MatPlayButtonComponent_keyup_space_HostBindingHandler($event) { return ctx.onPlayKey($event); }, false, ɵngcc0.ɵɵresolveDocument);
    } }, inputs: { play: "play", keyboard: "keyboard", video: "video" }, outputs: { playChanged: "playChanged" }, decls: 3, vars: 2, consts: [["mat-icon-button", "", 3, "click"], [4, "ngIf"]], template: function MatPlayButtonComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function MatPlayButtonComponent_Template_button_click_0_listener() { return ctx.toggleVideoPlayback(); });
        ɵngcc0.ɵɵtemplate(1, MatPlayButtonComponent_mat_icon_1_Template, 2, 0, "mat-icon", 1);
        ɵngcc0.ɵɵtemplate(2, MatPlayButtonComponent_mat_icon_2_Template, 2, 0, "mat-icon", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.play);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.play);
    } }, directives: [ɵngcc4.MatButton, ɵngcc1.NgIf, ɵngcc5.MatIcon], styles: [""] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatPlayButtonComponent, [{
        type: Component,
        args: [{
                selector: "mat-play-button",
                template: "<button mat-icon-button (click)=\"toggleVideoPlayback()\">\r\n  <mat-icon *ngIf=\"!play\">play_arrow</mat-icon>\r\n  <mat-icon *ngIf=\"play\">pause</mat-icon>\r\n</button>\r\n",
                styles: [""]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: EventService }]; }, { play: [{
            type: Input
        }], playChanged: [{
            type: Output
        }], keyboard: [{
            type: Input
        }], onPlayKey: [{
            type: HostListener,
            args: ["document:keyup.space", ["$event"]]
        }], video: [{
            type: Input
        }] }); })();
    return MatPlayButtonComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MatQualityControlComponent = /** @class */ (function () {
    function MatQualityControlComponent() {
    }
    /** @nocollapse */
    MatQualityControlComponent.ctorParameters = function () { return []; };
    MatQualityControlComponent.propDecorators = {
        video: [{ type: Input }]
    };
MatQualityControlComponent.ɵfac = function MatQualityControlComponent_Factory(t) { return new (t || MatQualityControlComponent)(); };
MatQualityControlComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatQualityControlComponent, selectors: [["mat-quality-control"]], inputs: { video: "video" }, decls: 1, vars: 1, consts: [["class", "quality", 4, "ngIf"], [1, "quality"]], template: function MatQualityControlComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, MatQualityControlComponent_div_0_Template, 2, 1, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.video && ctx.video.videoHeight);
    } }, directives: [ɵngcc1.NgIf], styles: [".quality[_ngcontent-%COMP%]{display:inline-block;font-size:12px;padding-left:12px;padding-right:12px}"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatQualityControlComponent, [{
        type: Component,
        args: [{
                selector: "mat-quality-control",
                template: "<div *ngIf=\"video && video.videoHeight\" class=\"quality\">{{ video.videoHeight }}p</div>\r\n",
                styles: [".quality{display:inline-block;font-size:12px;padding-left:12px;padding-right:12px}"]
            }]
    }], function () { return []; }, { video: [{
            type: Input
        }] }); })();
    return MatQualityControlComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MatSeekProgressControlComponent = /** @class */ (function () {
    function MatSeekProgressControlComponent(renderer, evt) {
        this.renderer = renderer;
        this.evt = evt;
        this.curTimePercent = 0;
        this.bufTimePercent = 0;
        this.video = null;
        this.color = "primary";
        this.currentTime = 0;
        this.currentTimeChanged = new EventEmitter();
        this.bufferedTime = 0;
        this.bufferedTimeChanged = new EventEmitter();
    }
    /**
     * @return {?}
     */
    MatSeekProgressControlComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.events = [
            { element: this.video, name: "seeking", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return _this.updateCurrentTime(_this.video.currentTime); }), dispose: null },
            { element: this.video, name: "canplaythrough", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return _this.updateBufferedTime(); }), dispose: null },
            { element: this.video, name: "timeupdate", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return _this.updateCurrentTime(_this.video.currentTime); }), dispose: null },
            { element: this.video, name: "progress", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return _this.updateBufferedTime(); }), dispose: null }
        ];
        this.evt.addEvents(this.renderer, this.events);
    };
    /**
     * @return {?}
     */
    MatSeekProgressControlComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.evt.removeEvents(this.events);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    MatSeekProgressControlComponent.prototype.seekVideo = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var percentage = value / 100;
        /** @type {?} */
        var newTime = this.video.duration * percentage;
        this.video.currentTime = newTime;
    };
    /**
     * @param {?} time
     * @return {?}
     */
    MatSeekProgressControlComponent.prototype.updateCurrentTime = /**
     * @param {?} time
     * @return {?}
     */
    function (time) {
        this.currentTime = time;
        this.curTimePercent = this.updateTime(this.currentTimeChanged, this.currentTime);
    };
    /**
     * @return {?}
     */
    MatSeekProgressControlComponent.prototype.updateBufferedTime = /**
     * @return {?}
     */
    function () {
        if (this.video.buffered.length > 0) {
            /** @type {?} */
            var largestBufferValue = 0;
            for (var i = 0; i < this.video.buffered.length; i++) {
                /** @type {?} */
                var cur = this.video.currentTime;
                /** @type {?} */
                var start = this.video.buffered.start(i);
                /** @type {?} */
                var end = this.video.buffered.end(i);
                if (start <= cur && end > cur && end - start > largestBufferValue) {
                    largestBufferValue = end;
                }
            }
            this.bufferedTime = largestBufferValue;
            this.bufTimePercent = this.updateTime(this.bufferedTimeChanged, this.bufferedTime);
        }
    };
    /**
     * @param {?} emitter
     * @param {?} time
     * @return {?}
     */
    MatSeekProgressControlComponent.prototype.updateTime = /**
     * @param {?} emitter
     * @param {?} time
     * @return {?}
     */
    function (emitter, time) {
        emitter.emit(time);
        return (time / this.video.duration) * 100;
    };
    /** @nocollapse */
    MatSeekProgressControlComponent.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: EventService }
    ]; };
    MatSeekProgressControlComponent.propDecorators = {
        video: [{ type: Input }],
        color: [{ type: Input }],
        currentTime: [{ type: Input }],
        currentTimeChanged: [{ type: Output }],
        bufferedTime: [{ type: Input }],
        bufferedTimeChanged: [{ type: Output }]
    };
MatSeekProgressControlComponent.ɵfac = function MatSeekProgressControlComponent_Factory(t) { return new (t || MatSeekProgressControlComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(EventService)); };
MatSeekProgressControlComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatSeekProgressControlComponent, selectors: [["mat-seek-progress-control"]], inputs: { video: "video", color: "color", currentTime: "currentTime", bufferedTime: "bufferedTime" }, outputs: { currentTimeChanged: "currentTimeChanged", bufferedTimeChanged: "bufferedTimeChanged" }, decls: 1, vars: 3, consts: [["mode", "buffer", "step", "0.01", 3, "color", "value", "bufferValue", "input"]], template: function MatSeekProgressControlComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "mat-slider-progress-bar", 0);
        ɵngcc0.ɵɵlistener("input", function MatSeekProgressControlComponent_Template_mat_slider_progress_bar_input_0_listener($event) { return ctx.seekVideo($event.value); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("color", ctx.color)("value", ctx.curTimePercent)("bufferValue", ctx.bufTimePercent);
    } }, directives: [MatSliderProgressBarComponent], styles: [""] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatSeekProgressControlComponent, [{
        type: Component,
        args: [{
                selector: "mat-seek-progress-control",
                template: "<mat-slider-progress-bar\r\n  [color]=\"color\"\r\n  mode=\"buffer\"\r\n  step=\"0.01\"\r\n  [value]=\"curTimePercent\"\r\n  [bufferValue]=\"bufTimePercent\"\r\n  (input)=\"seekVideo($event.value)\"\r\n></mat-slider-progress-bar>\r\n",
                styles: [""]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: EventService }]; }, { video: [{
            type: Input
        }], color: [{
            type: Input
        }], currentTime: [{
            type: Input
        }], currentTimeChanged: [{
            type: Output
        }], bufferedTime: [{
            type: Input
        }], bufferedTimeChanged: [{
            type: Output
        }] }); })();
    return MatSeekProgressControlComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MatTimeControlComponent = /** @class */ (function () {
    function MatTimeControlComponent() {
    }
    /** @nocollapse */
    MatTimeControlComponent.ctorParameters = function () { return []; };
    MatTimeControlComponent.propDecorators = {
        video: [{ type: Input }]
    };
MatTimeControlComponent.ɵfac = function MatTimeControlComponent_Factory(t) { return new (t || MatTimeControlComponent)(); };
MatTimeControlComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatTimeControlComponent, selectors: [["mat-time-control"]], inputs: { video: "video" }, decls: 4, vars: 6, consts: [[1, "playtime"]], template: function MatTimeControlComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵpipe(2, "secondsToTime");
        ɵngcc0.ɵɵpipe(3, "secondsToTime");
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate2("", ɵngcc0.ɵɵpipeBind1(2, 2, ctx.video == null ? null : ctx.video.currentTime), " / ", ɵngcc0.ɵɵpipeBind1(3, 4, ctx.video == null ? null : ctx.video.duration), "");
    } }, pipes: [SecondsToTimePipe], styles: [".playtime[_ngcontent-%COMP%]{display:inline;font-size:12px}"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatTimeControlComponent, [{
        type: Component,
        args: [{
                selector: "mat-time-control",
                template: "<div class=\"playtime\">{{ video?.currentTime | secondsToTime }} / {{ video?.duration | secondsToTime }}</div>\r\n",
                styles: [".playtime{display:inline;font-size:12px}"]
            }]
    }], function () { return []; }, { video: [{
            type: Input
        }] }); })();
    return MatTimeControlComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MatVideoSpinnerComponent = /** @class */ (function () {
    function MatVideoSpinnerComponent(renderer, evt) {
        this.renderer = renderer;
        this.evt = evt;
        this.spinner = "spin";
        this.videoBuffering = false;
        this.videoLoaded = false;
        this.events = [];
    }
    /**
     * @return {?}
     */
    MatVideoSpinnerComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.events = [
            { element: this.video, name: "loadstart", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return (_this.videoLoaded = false); }), dispose: null },
            { element: this.video, name: "loadedmetadata", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return (_this.videoLoaded = true); }), dispose: null },
            { element: this.video, name: "canplay", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return (_this.videoBuffering = false); }), dispose: null },
            { element: this.video, name: "waiting", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return (_this.videoBuffering = true); }), dispose: null },
            { element: this.video, name: "durationchange", callback: (/**
                 * @param {?} event
                 * @return {?}
                 */
                function (event) { return (_this.videoBuffering = true); }), dispose: null }
        ];
        this.video.onloadeddata = (/**
         * @return {?}
         */
        function () { return (_this.videoLoaded = true); });
        this.evt.addEvents(this.renderer, this.events);
    };
    /**
     * @return {?}
     */
    MatVideoSpinnerComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.video.onloadeddata = null;
        this.evt.removeEvents(this.events);
    };
    /** @nocollapse */
    MatVideoSpinnerComponent.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: EventService }
    ]; };
    MatVideoSpinnerComponent.propDecorators = {
        video: [{ type: Input }],
        spinner: [{ type: Input }]
    };
MatVideoSpinnerComponent.ɵfac = function MatVideoSpinnerComponent_Factory(t) { return new (t || MatVideoSpinnerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(EventService)); };
MatVideoSpinnerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatVideoSpinnerComponent, selectors: [["mat-video-spinner"]], inputs: { spinner: "spinner", video: "video" }, decls: 1, vars: 1, consts: [[3, "class", 4, "ngIf"]], template: function MatVideoSpinnerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, MatVideoSpinnerComponent_div_0_Template, 1, 2, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.videoLoaded || ctx.videoBuffering);
    } }, directives: [ɵngcc1.NgIf], styles: ["[_nghost-%COMP%]{position:absolute;left:calc(50% - 32px);top:calc(50% - 32px);z-index:1}", ".spin[_ngcontent-%COMP%]{box-sizing:border-box;width:64px;height:64px;border-radius:100%;border:10px solid rgba(255,255,255,.2);border-top-color:#fff;-webkit-animation:1s linear infinite spin;animation:1s linear infinite spin}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(360deg)}}@keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}", ".dot[_ngcontent-%COMP%]{width:64px;height:64px;background-color:#fff;border-radius:100%;-webkit-animation:1s ease-in-out infinite dot;animation:1s ease-in-out infinite dot}@-webkit-keyframes dot{0%{-webkit-transform:scale(0)}100%{-webkit-transform:scale(1);opacity:0}}@keyframes dot{0%{transform:scale(0)}100%{transform:scale(1);opacity:0}}", ".split-ring[_ngcontent-%COMP%]{display:inline-block;width:64px;height:64px}.split-ring[_ngcontent-%COMP%]:after{content:\" \";display:block;width:46px;height:46px;margin:1px;border-radius:50%;border:5px solid #fff;border-color:#fff transparent;-webkit-animation:1.2s linear infinite split-ring;animation:1.2s linear infinite split-ring}@-webkit-keyframes split-ring{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(360deg)}}@keyframes split-ring{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}", ".hourglass[_ngcontent-%COMP%]{display:inline-block;position:relative;width:64px;height:64px}.hourglass[_ngcontent-%COMP%]:after{content:\" \";display:block;border-radius:50%;width:0;height:0;margin:6px;box-sizing:border-box;border:26px solid #fff;border-color:#fff transparent;-webkit-animation:1.2s infinite hourglass;animation:1.2s infinite hourglass}@-webkit-keyframes hourglass{0%{-webkit-transform:rotate(0);-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19)}50%{-webkit-transform:rotate(360deg);-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1)}100%{-webkit-transform:rotate(720deg)}}@keyframes hourglass{0%{transform:rotate(0);-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19);animation-timing-function:cubic-bezier(.55,.055,.675,.19)}50%{transform:rotate(360deg);-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}100%{transform:rotate(720deg)}}"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatVideoSpinnerComponent, [{
        type: Component,
        args: [{
                selector: "mat-video-spinner",
                template: "<div *ngIf=\"!videoLoaded || videoBuffering\" [class]=\"spinner\"></div>\r\n",
                styles: [":host{position:absolute;left:calc(50% - 32px);top:calc(50% - 32px);z-index:1}", ".spin{box-sizing:border-box;width:64px;height:64px;border-radius:100%;border:10px solid rgba(255,255,255,.2);border-top-color:#fff;-webkit-animation:1s linear infinite spin;animation:1s linear infinite spin}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(360deg)}}@keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}", ".dot{width:64px;height:64px;background-color:#fff;border-radius:100%;-webkit-animation:1s ease-in-out infinite dot;animation:1s ease-in-out infinite dot}@-webkit-keyframes dot{0%{-webkit-transform:scale(0)}100%{-webkit-transform:scale(1);opacity:0}}@keyframes dot{0%{transform:scale(0)}100%{transform:scale(1);opacity:0}}", ".split-ring{display:inline-block;width:64px;height:64px}.split-ring:after{content:\" \";display:block;width:46px;height:46px;margin:1px;border-radius:50%;border:5px solid #fff;border-color:#fff transparent;-webkit-animation:1.2s linear infinite split-ring;animation:1.2s linear infinite split-ring}@-webkit-keyframes split-ring{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(360deg)}}@keyframes split-ring{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}", ".hourglass{display:inline-block;position:relative;width:64px;height:64px}.hourglass:after{content:\" \";display:block;border-radius:50%;width:0;height:0;margin:6px;box-sizing:border-box;border:26px solid #fff;border-color:#fff transparent;-webkit-animation:1.2s infinite hourglass;animation:1.2s infinite hourglass}@-webkit-keyframes hourglass{0%{-webkit-transform:rotate(0);-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19)}50%{-webkit-transform:rotate(360deg);-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1)}100%{-webkit-transform:rotate(720deg)}}@keyframes hourglass{0%{transform:rotate(0);-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19);animation-timing-function:cubic-bezier(.55,.055,.675,.19)}50%{transform:rotate(360deg);-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}100%{transform:rotate(720deg)}}"]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: EventService }]; }, { spinner: [{
            type: Input
        }], video: [{
            type: Input
        }] }); })();
    return MatVideoSpinnerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MatVolumeControlComponent = /** @class */ (function () {
    function MatVolumeControlComponent(evt) {
        this.evt = evt;
        this.video = null;
        this.color = "primary";
        this.volume = 1;
        this.volumeChanged = new EventEmitter();
        this.muted = false;
        this.mutedChanged = new EventEmitter();
        this.keyboard = true;
    }
    /**
     * @return {?}
     */
    MatVolumeControlComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.updateMuted(false);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    MatVolumeControlComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.muted) {
            this.updateMuted(false);
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    MatVolumeControlComponent.prototype.setVolume = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.volume = value;
        this.video.volume = this.volume;
        this.volumeChanged.emit(this.volume);
        if (this.volume > 0) {
            this.setMuted(false);
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    MatVolumeControlComponent.prototype.setMuted = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.muted !== value) {
            this.toggleMuted();
        }
    };
    /**
     * @return {?}
     */
    MatVolumeControlComponent.prototype.toggleMuted = /**
     * @return {?}
     */
    function () {
        this.muted = !this.muted;
        this.updateMuted();
    };
    /**
     * @param {?=} emitChange
     * @return {?}
     */
    MatVolumeControlComponent.prototype.updateMuted = /**
     * @param {?=} emitChange
     * @return {?}
     */
    function (emitChange) {
        if (emitChange === void 0) { emitChange = true; }
        if (this.video) {
            this.video.muted = this.muted;
        }
        if (emitChange) {
            this.mutedChanged.emit(this.muted);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MatVolumeControlComponent.prototype.onMuteKey = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.keyboard) {
            this.toggleMuted();
            event.preventDefault();
        }
    };
    /** @nocollapse */
    MatVolumeControlComponent.ctorParameters = function () { return [
        { type: EventService }
    ]; };
    MatVolumeControlComponent.propDecorators = {
        video: [{ type: Input }],
        color: [{ type: Input }],
        volume: [{ type: Input }],
        volumeChanged: [{ type: Output }],
        muted: [{ type: Input }],
        mutedChanged: [{ type: Output }],
        keyboard: [{ type: Input }],
        onMuteKey: [{ type: HostListener, args: ["document:keyup.m", ["$event"],] }]
    };
MatVolumeControlComponent.ɵfac = function MatVolumeControlComponent_Factory(t) { return new (t || MatVolumeControlComponent)(ɵngcc0.ɵɵdirectiveInject(EventService)); };
MatVolumeControlComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatVolumeControlComponent, selectors: [["mat-volume-control"]], hostBindings: function MatVolumeControlComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keyup.m", function MatVolumeControlComponent_keyup_m_HostBindingHandler($event) { return ctx.onMuteKey($event); }, false, ɵngcc0.ɵɵresolveDocument);
    } }, inputs: { video: "video", color: "color", volume: "volume", muted: "muted", keyboard: "keyboard" }, outputs: { volumeChanged: "volumeChanged", mutedChanged: "mutedChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 7, vars: 5, consts: [[1, "volume-control"], ["mat-icon-button", "", 3, "click"], [4, "ngIf"], ["min", "0", "max", "1", "step", "0.01", "value", "1", 1, "volume-slider", 3, "color", "input"]], template: function MatVolumeControlComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "button", 1);
        ɵngcc0.ɵɵlistener("click", function MatVolumeControlComponent_Template_button_click_1_listener() { return ctx.toggleMuted(); });
        ɵngcc0.ɵɵtemplate(2, MatVolumeControlComponent_mat_icon_2_Template, 2, 0, "mat-icon", 2);
        ɵngcc0.ɵɵtemplate(3, MatVolumeControlComponent_mat_icon_3_Template, 2, 0, "mat-icon", 2);
        ɵngcc0.ɵɵtemplate(4, MatVolumeControlComponent_mat_icon_4_Template, 2, 0, "mat-icon", 2);
        ɵngcc0.ɵɵtemplate(5, MatVolumeControlComponent_mat_icon_5_Template, 2, 0, "mat-icon", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "mat-slider", 3);
        ɵngcc0.ɵɵlistener("input", function MatVolumeControlComponent_Template_mat_slider_input_6_listener($event) { return ctx.setVolume($event.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.muted || ctx.volume === 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.muted && ctx.volume > 0 && ctx.volume < 0.25);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.muted && ctx.volume >= 0.25 && ctx.volume < 0.5);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.muted && ctx.volume >= 0.5);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("color", ctx.color);
    } }, directives: [ɵngcc4.MatButton, ɵngcc1.NgIf, ɵngcc6.MatSlider, ɵngcc5.MatIcon], styles: [".volume-control[_ngcontent-%COMP%]{display:inline}.volume-slider[_ngcontent-%COMP%]{margin-left:-15px} .mat-slider-thumb{border-color:transparent!important} .mat-slider-track-background{background-color:#d3d3d3!important;transform:translateX(0)!important}.volume-control[_ngcontent-%COMP%]   .volume-slider[_ngcontent-%COMP%]{visibility:hidden;opacity:0;min-width:0;width:0;transition:visibility .2s,opacity .2s linear,width .2s linear}.volume-control[_ngcontent-%COMP%]:hover   .volume-slider[_ngcontent-%COMP%]{visibility:visible;opacity:1;min-width:90px;width:90px;transition:opacity .2s linear,width .2s linear,min-width .2s linear}"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatVolumeControlComponent, [{
        type: Component,
        args: [{
                selector: "mat-volume-control",
                template: "<div class=\"volume-control\">\r\n  <button mat-icon-button (click)=\"toggleMuted()\">\r\n    <mat-icon *ngIf=\"muted || volume === 0\">volume_off</mat-icon>\r\n    <mat-icon *ngIf=\"!muted && volume > 0 && volume < 0.25\">volume_mute</mat-icon>\r\n    <mat-icon *ngIf=\"!muted && volume >= 0.25 && volume < 0.5\">volume_down</mat-icon>\r\n    <mat-icon *ngIf=\"!muted && volume >= 0.5\">volume_up</mat-icon>\r\n  </button>\r\n  <mat-slider class=\"volume-slider\" [color]=\"color\" min=\"0\" max=\"1\" step=\"0.01\" value=\"1\" (input)=\"setVolume($event.value)\"> </mat-slider>\r\n</div>\r\n",
                styles: [".volume-control{display:inline}.volume-slider{margin-left:-15px}::ng-deep.mat-slider-thumb{border-color:transparent!important}::ng-deep.mat-slider-track-background{background-color:#d3d3d3!important;transform:translateX(0)!important}.volume-control .volume-slider{visibility:hidden;opacity:0;min-width:0;width:0;transition:visibility .2s,opacity .2s linear,width .2s linear}.volume-control:hover .volume-slider{visibility:visible;opacity:1;min-width:90px;width:90px;transition:opacity .2s linear,width .2s linear,min-width .2s linear}"]
            }]
    }], function () { return [{ type: EventService }]; }, { video: [{
            type: Input
        }], color: [{
            type: Input
        }], volume: [{
            type: Input
        }], volumeChanged: [{
            type: Output
        }], muted: [{
            type: Input
        }], mutedChanged: [{
            type: Output
        }], keyboard: [{
            type: Input
        }], onMuteKey: [{
            type: HostListener,
            args: ["document:keyup.m", ["$event"]]
        }] }); })();
    return MatVolumeControlComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MatVideoModule = /** @class */ (function () {
    function MatVideoModule() {
    }
MatVideoModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MatVideoModule });
MatVideoModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MatVideoModule_Factory(t) { return new (t || MatVideoModule)(); }, providers: [FullscreenService, EventService], imports: [[CommonModule, MatIconModule, MatButtonModule, MatSliderModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatVideoModule, { declarations: function () { return [SecondsToTimePipe,
        MatVideoComponent,
        MatSliderProgressBarComponent,
        MatPlayButtonComponent,
        MatVolumeControlComponent,
        MatDownloadButtonComponent,
        MatFullscreenButtonComponent,
        MatTimeControlComponent,
        MatQualityControlComponent,
        MatVideoSpinnerComponent,
        MatSeekProgressControlComponent,
        MatVideoSourceDirective,
        MatVideoTrackDirective,
        MatFrameByFrameControlComponent]; }, imports: function () { return [CommonModule, MatIconModule, MatButtonModule, MatSliderModule]; }, exports: function () { return [MatVideoComponent,
        MatVideoSourceDirective,
        MatVideoTrackDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatVideoModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    SecondsToTimePipe,
                    MatVideoComponent,
                    MatSliderProgressBarComponent,
                    MatPlayButtonComponent,
                    MatVolumeControlComponent,
                    MatDownloadButtonComponent,
                    MatFullscreenButtonComponent,
                    MatTimeControlComponent,
                    MatQualityControlComponent,
                    MatVideoSpinnerComponent,
                    MatSeekProgressControlComponent,
                    MatVideoSourceDirective,
                    MatVideoTrackDirective,
                    MatFrameByFrameControlComponent
                ],
                imports: [CommonModule, MatIconModule, MatButtonModule, MatSliderModule],
                exports: [MatVideoComponent, MatVideoSourceDirective, MatVideoTrackDirective],
                providers: [FullscreenService, EventService]
            }]
    }], function () { return []; }, null); })();
    return MatVideoModule;
}());

export { MatVideoModule, SecondsToTimePipe as ɵa, MatVideoComponent as ɵb, EventService as ɵc, MatSliderProgressBarComponent as ɵd, MatPlayButtonComponent as ɵe, MatVolumeControlComponent as ɵf, MatDownloadButtonComponent as ɵg, MatFullscreenButtonComponent as ɵh, FullscreenService as ɵi, MatTimeControlComponent as ɵj, MatQualityControlComponent as ɵk, MatVideoSpinnerComponent as ɵl, MatSeekProgressControlComponent as ɵm, MatVideoSourceDirective as ɵn, MatVideoTrackDirective as ɵo, MatFrameByFrameControlComponent as ɵp };

//# sourceMappingURL=mat-video.js.map