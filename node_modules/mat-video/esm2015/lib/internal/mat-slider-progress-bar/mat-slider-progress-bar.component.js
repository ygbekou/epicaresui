/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Input, ElementRef, ChangeDetectorRef, ChangeDetectionStrategy, Optional, Attribute } from "@angular/core";
import { MatSlider, MAT_SLIDER_VALUE_ACCESSOR } from "@angular/material/slider";
import { FocusMonitor } from "@angular/cdk/a11y";
import { Directionality } from "@angular/cdk/bidi";
/**
 * Counter used to generate unique IDs for progress bars.
 * @type {?}
 */
let sliderprogressbarId = 0;
export class MatSliderProgressBarComponent extends MatSlider {
    /**
     * @param {?} elementRef
     * @param {?} focusMonitor
     * @param {?} changeDetectorRef
     * @param {?} dir
     * @param {?} tabIndex
     */
    constructor(elementRef, focusMonitor, changeDetectorRef, dir, tabIndex) {
        super(elementRef, focusMonitor, changeDetectorRef, dir, tabIndex);
        this.mode = "buffer";
        this.value = 0;
        this.pBufferValue = 0;
        /**
         * The id of the progress bar.
         */
        this.sliderprogressbarId = `mat-slider-progress-bar-${sliderprogressbarId++}`;
        this.tabIndex = parseInt(tabIndex, 10) || 0;
    }
    /**
     * Buffer value of the progress bar. Defaults to zero.
     * @return {?}
     */
    get bufferValue() {
        return this.pBufferValue;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set bufferValue(v) {
        this.pBufferValue = clamp(v || 0);
    }
    /**
     * CSS styles for the track fill element.
     * @return {?}
     */
    get _trackBufferStyles() {
        if (this.mode === "buffer") {
            /** @type {?} */
            const axis = this.vertical ? "Y" : "X";
            return {
                transform: `translate${axis}(0px) scale${axis}(${this.pBufferValue / 100})`
            };
        }
    }
}
MatSliderProgressBarComponent.decorators = [
    { type: Component, args: [{
                selector: "mat-slider-progress-bar",
                template: "<div class=\"mat-slider-wrapper\" #sliderWrapper>\r\n  <div class=\"mat-slider-track-wrapper\">\r\n    <svg width=\"100%\" height=\"2\" focusable=\"false\" class=\"mat-slider-progress-background\">\r\n      <defs>\r\n        <pattern [id]=\"sliderprogressbarId\" x=\"2.5\" y=\"0\" width=\"5\" height=\"2.5\" patternUnits=\"userSpaceOnUse\">\r\n          <circle cx=\"1.25\" cy=\"1.25\" r=\"1.25\" />\r\n        </pattern>\r\n      </defs>\r\n      <rect [attr.fill]=\"'url(#' + sliderprogressbarId + ')'\" width=\"100%\" height=\"100%\" />\r\n    </svg>\r\n    <div class=\"mat-slider-track-fill mat-slider-track-buffer\" [ngStyle]=\"_trackBufferStyles\"></div>\r\n    <div class=\"mat-slider-track-fill\" [ngStyle]=\"_trackFillStyles\"></div>\r\n  </div>\r\n  <div class=\"mat-slider-ticks-container\" [ngStyle]=\"_ticksContainerStyles\">\r\n    <div class=\"mat-slider-ticks\" [ngStyle]=\"_ticksStyles\"></div>\r\n  </div>\r\n  <div class=\"mat-slider-thumb-container\" [ngStyle]=\"_thumbContainerStyles\">\r\n    <div class=\"mat-slider-focus-ring\"></div>\r\n    <div class=\"mat-slider-thumb\"></div>\r\n    <div class=\"mat-slider-thumb-label\">\r\n      <span class=\"mat-slider-thumb-label-text\">{{ displayValue }}</span>\r\n    </div>\r\n  </div>\r\n</div>\r\n",
                providers: [MAT_SLIDER_VALUE_ACCESSOR],
                host: {
                    "(focus)": "_onFocus()",
                    "(blur)": "_onBlur()",
                    "(click)": 'this["_onClick"] ? this["_onClick"]($event) : null',
                    // Angular 5/6 support
                    "(mousedown)": 'this["_onMousedown"] ? this["_onMousedown"]($event) : null',
                    // Angular 7 support
                    "(keydown)": "_onKeydown($event)",
                    "(keyup)": "_onKeyup()",
                    "(mouseenter)": "_onMouseenter()",
                    "(slide)": "_onSlide($event)",
                    "(slideend)": "_onSlideEnd()",
                    "(slidestart)": "_onSlideStart($event)",
                    class: "mat-slider",
                    role: "slider",
                    "[tabIndex]": "tabIndex",
                    "[attr.aria-disabled]": "disabled",
                    "[attr.aria-valuemax]": "max",
                    "[attr.aria-valuemin]": "min",
                    "[attr.aria-valuenow]": "value",
                    "[attr.aria-orientation]": 'vertical ? "vertical" : "horizontal"',
                    "[class.mat-slider-disabled]": "disabled",
                    "[class.mat-slider-has-ticks]": "tickInterval",
                    "[class.mat-slider-horizontal]": "!vertical",
                    "[class.mat-slider-axis-inverted]": "_invertAxis",
                    "[class.mat-slider-sliding]": "_isSliding",
                    "[class.mat-slider-thumb-label-showing]": "thumbLabel",
                    "[class.mat-slider-vertical]": "vertical",
                    "[class.mat-slider-min-value]": "_isMinValue",
                    "[class.mat-slider-hide-last-tick]": "disabled || _isMinValue && _thumbGap && _invertAxis"
                },
                inputs: ["disabled", "color", "tabIndex"],
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{width:100%}.mat-slider-progress-background{position:absolute;height:2px;width:100%;fill:#d3d3d3}.mat-slider-track-buffer{background-color:#d3d3d3!important}.mat-slider-thumb{border-color:transparent!important;visibility:hidden;opacity:0;transition:visibility .2s,opacity .2s linear}:host:hover .mat-slider-thumb{visibility:visible;opacity:1;transition:opacity .2s linear}"]
            }] }
];
/** @nocollapse */
MatSliderProgressBarComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: FocusMonitor },
    { type: ChangeDetectorRef },
    { type: Directionality, decorators: [{ type: Optional }] },
    { type: String, decorators: [{ type: Attribute, args: ["tabindex",] }] }
];
MatSliderProgressBarComponent.propDecorators = {
    mode: [{ type: Input }],
    value: [{ type: Input }],
    bufferValue: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    MatSliderProgressBarComponent.prototype.mode;
    /** @type {?} */
    MatSliderProgressBarComponent.prototype.value;
    /**
     * @type {?}
     * @private
     */
    MatSliderProgressBarComponent.prototype.pBufferValue;
    /**
     * The id of the progress bar.
     * @type {?}
     */
    MatSliderProgressBarComponent.prototype.sliderprogressbarId;
}
/**
 * Clamps a value to be between two numbers, by default 0 and 100.
 * @param {?} v
 * @param {?=} min
 * @param {?=} max
 * @return {?}
 */
function clamp(v, min = 0, max = 100) {
    return Math.max(min, Math.min(max, v));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0LXNsaWRlci1wcm9ncmVzcy1iYXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbWF0LXZpZGVvLyIsInNvdXJjZXMiOlsibGliL2ludGVybmFsL21hdC1zbGlkZXItcHJvZ3Jlc3MtYmFyL21hdC1zbGlkZXItcHJvZ3Jlc3MtYmFyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLGlCQUFpQixFQUFFLHVCQUF1QixFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDOUgsT0FBTyxFQUFFLFNBQVMsRUFBRSx5QkFBeUIsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ2hGLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNqRCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7Ozs7O0lBRy9DLG1CQUFtQixHQUFHLENBQUM7QUF1QzNCLE1BQU0sT0FBTyw2QkFBOEIsU0FBUSxTQUFTOzs7Ozs7OztJQWdCMUQsWUFDRSxVQUFzQixFQUN0QixZQUEwQixFQUMxQixpQkFBb0MsRUFDeEIsR0FBbUIsRUFDUixRQUFnQjtRQUV2QyxLQUFLLENBQUMsVUFBVSxFQUFFLFlBQVksRUFBRSxpQkFBaUIsRUFBRSxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7UUF0QjNELFNBQUksR0FBRyxRQUFRLENBQUM7UUFDaEIsVUFBSyxHQUFHLENBQUMsQ0FBQztRQVNYLGlCQUFZLEdBQUcsQ0FBQyxDQUFDOzs7O1FBR3pCLHdCQUFtQixHQUFHLDJCQUEyQixtQkFBbUIsRUFBRSxFQUFFLENBQUM7UUFVdkUsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM5QyxDQUFDOzs7OztJQXJCRCxJQUNJLFdBQVc7UUFDYixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7SUFDM0IsQ0FBQzs7Ozs7SUFDRCxJQUFJLFdBQVcsQ0FBQyxDQUFTO1FBQ3ZCLElBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUNwQyxDQUFDOzs7OztJQWtCRCxJQUFJLGtCQUFrQjtRQUNwQixJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFOztrQkFDcEIsSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRztZQUN0QyxPQUFPO2dCQUNMLFNBQVMsRUFBRSxZQUFZLElBQUksY0FBYyxJQUFJLElBQUksSUFBSSxDQUFDLFlBQVksR0FBRyxHQUFHLEdBQUc7YUFDNUUsQ0FBQztTQUNIO0lBQ0gsQ0FBQzs7O1lBeEVGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUseUJBQXlCO2dCQUNuQyxrd0NBQXVEO2dCQUV2RCxTQUFTLEVBQUUsQ0FBQyx5QkFBeUIsQ0FBQztnQkFDdEMsSUFBSSxFQUFFO29CQUNKLFNBQVMsRUFBRSxZQUFZO29CQUN2QixRQUFRLEVBQUUsV0FBVztvQkFDckIsU0FBUyxFQUFFLG9EQUFvRDs7b0JBQy9ELGFBQWEsRUFBRSw0REFBNEQ7O29CQUMzRSxXQUFXLEVBQUUsb0JBQW9CO29CQUNqQyxTQUFTLEVBQUUsWUFBWTtvQkFDdkIsY0FBYyxFQUFFLGlCQUFpQjtvQkFDakMsU0FBUyxFQUFFLGtCQUFrQjtvQkFDN0IsWUFBWSxFQUFFLGVBQWU7b0JBQzdCLGNBQWMsRUFBRSx1QkFBdUI7b0JBQ3ZDLEtBQUssRUFBRSxZQUFZO29CQUNuQixJQUFJLEVBQUUsUUFBUTtvQkFDZCxZQUFZLEVBQUUsVUFBVTtvQkFDeEIsc0JBQXNCLEVBQUUsVUFBVTtvQkFDbEMsc0JBQXNCLEVBQUUsS0FBSztvQkFDN0Isc0JBQXNCLEVBQUUsS0FBSztvQkFDN0Isc0JBQXNCLEVBQUUsT0FBTztvQkFDL0IseUJBQXlCLEVBQUUsc0NBQXNDO29CQUNqRSw2QkFBNkIsRUFBRSxVQUFVO29CQUN6Qyw4QkFBOEIsRUFBRSxjQUFjO29CQUM5QywrQkFBK0IsRUFBRSxXQUFXO29CQUM1QyxrQ0FBa0MsRUFBRSxhQUFhO29CQUNqRCw0QkFBNEIsRUFBRSxZQUFZO29CQUMxQyx3Q0FBd0MsRUFBRSxZQUFZO29CQUN0RCw2QkFBNkIsRUFBRSxVQUFVO29CQUN6Qyw4QkFBOEIsRUFBRSxhQUFhO29CQUM3QyxtQ0FBbUMsRUFBRSxxREFBcUQ7aUJBQzNGO2dCQUNELE1BQU0sRUFBRSxDQUFDLFVBQVUsRUFBRSxPQUFPLEVBQUUsVUFBVSxDQUFDO2dCQUN6QyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTs7YUFDaEQ7Ozs7WUE1QzBCLFVBQVU7WUFFNUIsWUFBWTtZQUZrQixpQkFBaUI7WUFHL0MsY0FBYyx1QkE4RGxCLFFBQVE7eUNBQ1IsU0FBUyxTQUFDLFVBQVU7OzttQkFwQnRCLEtBQUs7b0JBQ0wsS0FBSzswQkFFTCxLQUFLOzs7O0lBSE4sNkNBQXlCOztJQUN6Qiw4Q0FBbUI7Ozs7O0lBU25CLHFEQUF5Qjs7Ozs7SUFHekIsNERBQXlFOzs7Ozs7Ozs7QUF5QjNFLFNBQVMsS0FBSyxDQUFDLENBQVMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxHQUFHO0lBQzFDLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN6QyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgRWxlbWVudFJlZiwgQ2hhbmdlRGV0ZWN0b3JSZWYsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBPcHRpb25hbCwgQXR0cmlidXRlIH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcclxuaW1wb3J0IHsgTWF0U2xpZGVyLCBNQVRfU0xJREVSX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSBcIkBhbmd1bGFyL21hdGVyaWFsL3NsaWRlclwiO1xyXG5pbXBvcnQgeyBGb2N1c01vbml0b3IgfSBmcm9tIFwiQGFuZ3VsYXIvY2RrL2ExMXlcIjtcclxuaW1wb3J0IHsgRGlyZWN0aW9uYWxpdHkgfSBmcm9tIFwiQGFuZ3VsYXIvY2RrL2JpZGlcIjtcclxuXHJcbi8qKiBDb3VudGVyIHVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcyBmb3IgcHJvZ3Jlc3MgYmFycy4gKi9cclxubGV0IHNsaWRlcnByb2dyZXNzYmFySWQgPSAwO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6IFwibWF0LXNsaWRlci1wcm9ncmVzcy1iYXJcIixcclxuICB0ZW1wbGF0ZVVybDogXCIuL21hdC1zbGlkZXItcHJvZ3Jlc3MtYmFyLmNvbXBvbmVudC5odG1sXCIsXHJcbiAgc3R5bGVVcmxzOiBbXCIuL21hdC1zbGlkZXItcHJvZ3Jlc3MtYmFyLmNvbXBvbmVudC5zY3NzXCJdLFxyXG4gIHByb3ZpZGVyczogW01BVF9TTElERVJfVkFMVUVfQUNDRVNTT1JdLFxyXG4gIGhvc3Q6IHtcclxuICAgIFwiKGZvY3VzKVwiOiBcIl9vbkZvY3VzKClcIixcclxuICAgIFwiKGJsdXIpXCI6IFwiX29uQmx1cigpXCIsXHJcbiAgICBcIihjbGljaylcIjogJ3RoaXNbXCJfb25DbGlja1wiXSA/IHRoaXNbXCJfb25DbGlja1wiXSgkZXZlbnQpIDogbnVsbCcsIC8vIEFuZ3VsYXIgNS82IHN1cHBvcnRcclxuICAgIFwiKG1vdXNlZG93bilcIjogJ3RoaXNbXCJfb25Nb3VzZWRvd25cIl0gPyB0aGlzW1wiX29uTW91c2Vkb3duXCJdKCRldmVudCkgOiBudWxsJywgLy8gQW5ndWxhciA3IHN1cHBvcnRcclxuICAgIFwiKGtleWRvd24pXCI6IFwiX29uS2V5ZG93bigkZXZlbnQpXCIsXHJcbiAgICBcIihrZXl1cClcIjogXCJfb25LZXl1cCgpXCIsXHJcbiAgICBcIihtb3VzZWVudGVyKVwiOiBcIl9vbk1vdXNlZW50ZXIoKVwiLFxyXG4gICAgXCIoc2xpZGUpXCI6IFwiX29uU2xpZGUoJGV2ZW50KVwiLFxyXG4gICAgXCIoc2xpZGVlbmQpXCI6IFwiX29uU2xpZGVFbmQoKVwiLFxyXG4gICAgXCIoc2xpZGVzdGFydClcIjogXCJfb25TbGlkZVN0YXJ0KCRldmVudClcIixcclxuICAgIGNsYXNzOiBcIm1hdC1zbGlkZXJcIixcclxuICAgIHJvbGU6IFwic2xpZGVyXCIsXHJcbiAgICBcIlt0YWJJbmRleF1cIjogXCJ0YWJJbmRleFwiLFxyXG4gICAgXCJbYXR0ci5hcmlhLWRpc2FibGVkXVwiOiBcImRpc2FibGVkXCIsXHJcbiAgICBcIlthdHRyLmFyaWEtdmFsdWVtYXhdXCI6IFwibWF4XCIsXHJcbiAgICBcIlthdHRyLmFyaWEtdmFsdWVtaW5dXCI6IFwibWluXCIsXHJcbiAgICBcIlthdHRyLmFyaWEtdmFsdWVub3ddXCI6IFwidmFsdWVcIixcclxuICAgIFwiW2F0dHIuYXJpYS1vcmllbnRhdGlvbl1cIjogJ3ZlcnRpY2FsID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCInLFxyXG4gICAgXCJbY2xhc3MubWF0LXNsaWRlci1kaXNhYmxlZF1cIjogXCJkaXNhYmxlZFwiLFxyXG4gICAgXCJbY2xhc3MubWF0LXNsaWRlci1oYXMtdGlja3NdXCI6IFwidGlja0ludGVydmFsXCIsXHJcbiAgICBcIltjbGFzcy5tYXQtc2xpZGVyLWhvcml6b250YWxdXCI6IFwiIXZlcnRpY2FsXCIsXHJcbiAgICBcIltjbGFzcy5tYXQtc2xpZGVyLWF4aXMtaW52ZXJ0ZWRdXCI6IFwiX2ludmVydEF4aXNcIixcclxuICAgIFwiW2NsYXNzLm1hdC1zbGlkZXItc2xpZGluZ11cIjogXCJfaXNTbGlkaW5nXCIsXHJcbiAgICBcIltjbGFzcy5tYXQtc2xpZGVyLXRodW1iLWxhYmVsLXNob3dpbmddXCI6IFwidGh1bWJMYWJlbFwiLFxyXG4gICAgXCJbY2xhc3MubWF0LXNsaWRlci12ZXJ0aWNhbF1cIjogXCJ2ZXJ0aWNhbFwiLFxyXG4gICAgXCJbY2xhc3MubWF0LXNsaWRlci1taW4tdmFsdWVdXCI6IFwiX2lzTWluVmFsdWVcIixcclxuICAgIFwiW2NsYXNzLm1hdC1zbGlkZXItaGlkZS1sYXN0LXRpY2tdXCI6IFwiZGlzYWJsZWQgfHwgX2lzTWluVmFsdWUgJiYgX3RodW1iR2FwICYmIF9pbnZlcnRBeGlzXCJcclxuICB9LFxyXG4gIGlucHV0czogW1wiZGlzYWJsZWRcIiwgXCJjb2xvclwiLCBcInRhYkluZGV4XCJdLFxyXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBNYXRTbGlkZXJQcm9ncmVzc0JhckNvbXBvbmVudCBleHRlbmRzIE1hdFNsaWRlciB7XHJcbiAgQElucHV0KCkgbW9kZSA9IFwiYnVmZmVyXCI7XHJcbiAgQElucHV0KCkgdmFsdWUgPSAwO1xyXG4gIC8qKiBCdWZmZXIgdmFsdWUgb2YgdGhlIHByb2dyZXNzIGJhci4gRGVmYXVsdHMgdG8gemVyby4gKi9cclxuICBASW5wdXQoKVxyXG4gIGdldCBidWZmZXJWYWx1ZSgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMucEJ1ZmZlclZhbHVlO1xyXG4gIH1cclxuICBzZXQgYnVmZmVyVmFsdWUodjogbnVtYmVyKSB7XHJcbiAgICB0aGlzLnBCdWZmZXJWYWx1ZSA9IGNsYW1wKHYgfHwgMCk7XHJcbiAgfVxyXG4gIHByaXZhdGUgcEJ1ZmZlclZhbHVlID0gMDtcclxuXHJcbiAgLyoqIFRoZSBpZCBvZiB0aGUgcHJvZ3Jlc3MgYmFyLiAqL1xyXG4gIHNsaWRlcnByb2dyZXNzYmFySWQgPSBgbWF0LXNsaWRlci1wcm9ncmVzcy1iYXItJHtzbGlkZXJwcm9ncmVzc2JhcklkKyt9YDtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxyXG4gICAgZm9jdXNNb25pdG9yOiBGb2N1c01vbml0b3IsXHJcbiAgICBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgICBAT3B0aW9uYWwoKSBkaXI6IERpcmVjdGlvbmFsaXR5LFxyXG4gICAgQEF0dHJpYnV0ZShcInRhYmluZGV4XCIpIHRhYkluZGV4OiBzdHJpbmdcclxuICApIHtcclxuICAgIHN1cGVyKGVsZW1lbnRSZWYsIGZvY3VzTW9uaXRvciwgY2hhbmdlRGV0ZWN0b3JSZWYsIGRpciwgdGFiSW5kZXgpO1xyXG4gICAgdGhpcy50YWJJbmRleCA9IHBhcnNlSW50KHRhYkluZGV4LCAxMCkgfHwgMDtcclxuICB9XHJcblxyXG4gIC8qKiBDU1Mgc3R5bGVzIGZvciB0aGUgdHJhY2sgZmlsbCBlbGVtZW50LiAqL1xyXG4gIGdldCBfdHJhY2tCdWZmZXJTdHlsZXMoKTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSB7XHJcbiAgICBpZiAodGhpcy5tb2RlID09PSBcImJ1ZmZlclwiKSB7XHJcbiAgICAgIGNvbnN0IGF4aXMgPSB0aGlzLnZlcnRpY2FsID8gXCJZXCIgOiBcIlhcIjtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUke2F4aXN9KDBweCkgc2NhbGUke2F4aXN9KCR7dGhpcy5wQnVmZmVyVmFsdWUgLyAxMDB9KWBcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKiBDbGFtcHMgYSB2YWx1ZSB0byBiZSBiZXR3ZWVuIHR3byBudW1iZXJzLCBieSBkZWZhdWx0IDAgYW5kIDEwMC4gKi9cclxuZnVuY3Rpb24gY2xhbXAodjogbnVtYmVyLCBtaW4gPSAwLCBtYXggPSAxMDApIHtcclxuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHYpKTtcclxufVxyXG4iXX0=