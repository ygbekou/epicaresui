/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, Input, ElementRef, ChangeDetectorRef, ChangeDetectionStrategy, Optional, Attribute } from "@angular/core";
import { MatSlider, MAT_SLIDER_VALUE_ACCESSOR } from "@angular/material/slider";
import { FocusMonitor } from "@angular/cdk/a11y";
import { Directionality } from "@angular/cdk/bidi";
/**
 * Counter used to generate unique IDs for progress bars.
 * @type {?}
 */
var sliderprogressbarId = 0;
var MatSliderProgressBarComponent = /** @class */ (function (_super) {
    tslib_1.__extends(MatSliderProgressBarComponent, _super);
    function MatSliderProgressBarComponent(elementRef, focusMonitor, changeDetectorRef, dir, tabIndex) {
        var _this = _super.call(this, elementRef, focusMonitor, changeDetectorRef, dir, tabIndex) || this;
        _this.mode = "buffer";
        _this.value = 0;
        _this.pBufferValue = 0;
        /**
         * The id of the progress bar.
         */
        _this.sliderprogressbarId = "mat-slider-progress-bar-" + sliderprogressbarId++;
        _this.tabIndex = parseInt(tabIndex, 10) || 0;
        return _this;
    }
    Object.defineProperty(MatSliderProgressBarComponent.prototype, "bufferValue", {
        /** Buffer value of the progress bar. Defaults to zero. */
        get: /**
         * Buffer value of the progress bar. Defaults to zero.
         * @return {?}
         */
        function () {
            return this.pBufferValue;
        },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            this.pBufferValue = clamp(v || 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatSliderProgressBarComponent.prototype, "_trackBufferStyles", {
        /** CSS styles for the track fill element. */
        get: /**
         * CSS styles for the track fill element.
         * @return {?}
         */
        function () {
            if (this.mode === "buffer") {
                /** @type {?} */
                var axis = this.vertical ? "Y" : "X";
                return {
                    transform: "translate" + axis + "(0px) scale" + axis + "(" + this.pBufferValue / 100 + ")"
                };
            }
        },
        enumerable: true,
        configurable: true
    });
    MatSliderProgressBarComponent.decorators = [
        { type: Component, args: [{
                    selector: "mat-slider-progress-bar",
                    template: "<div class=\"mat-slider-wrapper\" #sliderWrapper>\r\n  <div class=\"mat-slider-track-wrapper\">\r\n    <svg width=\"100%\" height=\"2\" focusable=\"false\" class=\"mat-slider-progress-background\">\r\n      <defs>\r\n        <pattern [id]=\"sliderprogressbarId\" x=\"2.5\" y=\"0\" width=\"5\" height=\"2.5\" patternUnits=\"userSpaceOnUse\">\r\n          <circle cx=\"1.25\" cy=\"1.25\" r=\"1.25\" />\r\n        </pattern>\r\n      </defs>\r\n      <rect [attr.fill]=\"'url(#' + sliderprogressbarId + ')'\" width=\"100%\" height=\"100%\" />\r\n    </svg>\r\n    <div class=\"mat-slider-track-fill mat-slider-track-buffer\" [ngStyle]=\"_trackBufferStyles\"></div>\r\n    <div class=\"mat-slider-track-fill\" [ngStyle]=\"_trackFillStyles\"></div>\r\n  </div>\r\n  <div class=\"mat-slider-ticks-container\" [ngStyle]=\"_ticksContainerStyles\">\r\n    <div class=\"mat-slider-ticks\" [ngStyle]=\"_ticksStyles\"></div>\r\n  </div>\r\n  <div class=\"mat-slider-thumb-container\" [ngStyle]=\"_thumbContainerStyles\">\r\n    <div class=\"mat-slider-focus-ring\"></div>\r\n    <div class=\"mat-slider-thumb\"></div>\r\n    <div class=\"mat-slider-thumb-label\">\r\n      <span class=\"mat-slider-thumb-label-text\">{{ displayValue }}</span>\r\n    </div>\r\n  </div>\r\n</div>\r\n",
                    providers: [MAT_SLIDER_VALUE_ACCESSOR],
                    host: {
                        "(focus)": "_onFocus()",
                        "(blur)": "_onBlur()",
                        "(click)": 'this["_onClick"] ? this["_onClick"]($event) : null',
                        // Angular 5/6 support
                        "(mousedown)": 'this["_onMousedown"] ? this["_onMousedown"]($event) : null',
                        // Angular 7 support
                        "(keydown)": "_onKeydown($event)",
                        "(keyup)": "_onKeyup()",
                        "(mouseenter)": "_onMouseenter()",
                        "(slide)": "_onSlide($event)",
                        "(slideend)": "_onSlideEnd()",
                        "(slidestart)": "_onSlideStart($event)",
                        class: "mat-slider",
                        role: "slider",
                        "[tabIndex]": "tabIndex",
                        "[attr.aria-disabled]": "disabled",
                        "[attr.aria-valuemax]": "max",
                        "[attr.aria-valuemin]": "min",
                        "[attr.aria-valuenow]": "value",
                        "[attr.aria-orientation]": 'vertical ? "vertical" : "horizontal"',
                        "[class.mat-slider-disabled]": "disabled",
                        "[class.mat-slider-has-ticks]": "tickInterval",
                        "[class.mat-slider-horizontal]": "!vertical",
                        "[class.mat-slider-axis-inverted]": "_invertAxis",
                        "[class.mat-slider-sliding]": "_isSliding",
                        "[class.mat-slider-thumb-label-showing]": "thumbLabel",
                        "[class.mat-slider-vertical]": "vertical",
                        "[class.mat-slider-min-value]": "_isMinValue",
                        "[class.mat-slider-hide-last-tick]": "disabled || _isMinValue && _thumbGap && _invertAxis"
                    },
                    inputs: ["disabled", "color", "tabIndex"],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [":host{width:100%}.mat-slider-progress-background{position:absolute;height:2px;width:100%;fill:#d3d3d3}.mat-slider-track-buffer{background-color:#d3d3d3!important}.mat-slider-thumb{border-color:transparent!important;visibility:hidden;opacity:0;transition:visibility .2s,opacity .2s linear}:host:hover .mat-slider-thumb{visibility:visible;opacity:1;transition:opacity .2s linear}"]
                }] }
    ];
    /** @nocollapse */
    MatSliderProgressBarComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: FocusMonitor },
        { type: ChangeDetectorRef },
        { type: Directionality, decorators: [{ type: Optional }] },
        { type: String, decorators: [{ type: Attribute, args: ["tabindex",] }] }
    ]; };
    MatSliderProgressBarComponent.propDecorators = {
        mode: [{ type: Input }],
        value: [{ type: Input }],
        bufferValue: [{ type: Input }]
    };
    return MatSliderProgressBarComponent;
}(MatSlider));
export { MatSliderProgressBarComponent };
if (false) {
    /** @type {?} */
    MatSliderProgressBarComponent.prototype.mode;
    /** @type {?} */
    MatSliderProgressBarComponent.prototype.value;
    /**
     * @type {?}
     * @private
     */
    MatSliderProgressBarComponent.prototype.pBufferValue;
    /**
     * The id of the progress bar.
     * @type {?}
     */
    MatSliderProgressBarComponent.prototype.sliderprogressbarId;
}
/**
 * Clamps a value to be between two numbers, by default 0 and 100.
 * @param {?} v
 * @param {?=} min
 * @param {?=} max
 * @return {?}
 */
function clamp(v, min, max) {
    if (min === void 0) { min = 0; }
    if (max === void 0) { max = 100; }
    return Math.max(min, Math.min(max, v));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0LXNsaWRlci1wcm9ncmVzcy1iYXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbWF0LXZpZGVvLyIsInNvdXJjZXMiOlsibGliL2ludGVybmFsL21hdC1zbGlkZXItcHJvZ3Jlc3MtYmFyL21hdC1zbGlkZXItcHJvZ3Jlc3MtYmFyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxpQkFBaUIsRUFBRSx1QkFBdUIsRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzlILE9BQU8sRUFBRSxTQUFTLEVBQUUseUJBQXlCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUNoRixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDakQsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG1CQUFtQixDQUFDOzs7OztJQUcvQyxtQkFBbUIsR0FBRyxDQUFDO0FBRTNCO0lBcUNtRCx5REFBUztJQWdCMUQsdUNBQ0UsVUFBc0IsRUFDdEIsWUFBMEIsRUFDMUIsaUJBQW9DLEVBQ3hCLEdBQW1CLEVBQ1IsUUFBZ0I7UUFMekMsWUFPRSxrQkFBTSxVQUFVLEVBQUUsWUFBWSxFQUFFLGlCQUFpQixFQUFFLEdBQUcsRUFBRSxRQUFRLENBQUMsU0FFbEU7UUF4QlEsVUFBSSxHQUFHLFFBQVEsQ0FBQztRQUNoQixXQUFLLEdBQUcsQ0FBQyxDQUFDO1FBU1gsa0JBQVksR0FBRyxDQUFDLENBQUM7Ozs7UUFHekIseUJBQW1CLEdBQUcsNkJBQTJCLG1CQUFtQixFQUFJLENBQUM7UUFVdkUsS0FBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQzs7SUFDOUMsQ0FBQztJQXJCRCxzQkFDSSxzREFBVztRQUZmLDBEQUEwRDs7Ozs7UUFDMUQ7WUFFRSxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7UUFDM0IsQ0FBQzs7Ozs7UUFDRCxVQUFnQixDQUFTO1lBQ3ZCLElBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNwQyxDQUFDOzs7T0FIQTtJQXFCRCxzQkFBSSw2REFBa0I7UUFEdEIsNkNBQTZDOzs7OztRQUM3QztZQUNFLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxRQUFRLEVBQUU7O29CQUNwQixJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHO2dCQUN0QyxPQUFPO29CQUNMLFNBQVMsRUFBRSxjQUFZLElBQUksbUJBQWMsSUFBSSxTQUFJLElBQUksQ0FBQyxZQUFZLEdBQUcsR0FBRyxNQUFHO2lCQUM1RSxDQUFDO2FBQ0g7UUFDSCxDQUFDOzs7T0FBQTs7Z0JBeEVGLFNBQVMsU0FBQztvQkFDVCxRQUFRLEVBQUUseUJBQXlCO29CQUNuQyxrd0NBQXVEO29CQUV2RCxTQUFTLEVBQUUsQ0FBQyx5QkFBeUIsQ0FBQztvQkFDdEMsSUFBSSxFQUFFO3dCQUNKLFNBQVMsRUFBRSxZQUFZO3dCQUN2QixRQUFRLEVBQUUsV0FBVzt3QkFDckIsU0FBUyxFQUFFLG9EQUFvRDs7d0JBQy9ELGFBQWEsRUFBRSw0REFBNEQ7O3dCQUMzRSxXQUFXLEVBQUUsb0JBQW9CO3dCQUNqQyxTQUFTLEVBQUUsWUFBWTt3QkFDdkIsY0FBYyxFQUFFLGlCQUFpQjt3QkFDakMsU0FBUyxFQUFFLGtCQUFrQjt3QkFDN0IsWUFBWSxFQUFFLGVBQWU7d0JBQzdCLGNBQWMsRUFBRSx1QkFBdUI7d0JBQ3ZDLEtBQUssRUFBRSxZQUFZO3dCQUNuQixJQUFJLEVBQUUsUUFBUTt3QkFDZCxZQUFZLEVBQUUsVUFBVTt3QkFDeEIsc0JBQXNCLEVBQUUsVUFBVTt3QkFDbEMsc0JBQXNCLEVBQUUsS0FBSzt3QkFDN0Isc0JBQXNCLEVBQUUsS0FBSzt3QkFDN0Isc0JBQXNCLEVBQUUsT0FBTzt3QkFDL0IseUJBQXlCLEVBQUUsc0NBQXNDO3dCQUNqRSw2QkFBNkIsRUFBRSxVQUFVO3dCQUN6Qyw4QkFBOEIsRUFBRSxjQUFjO3dCQUM5QywrQkFBK0IsRUFBRSxXQUFXO3dCQUM1QyxrQ0FBa0MsRUFBRSxhQUFhO3dCQUNqRCw0QkFBNEIsRUFBRSxZQUFZO3dCQUMxQyx3Q0FBd0MsRUFBRSxZQUFZO3dCQUN0RCw2QkFBNkIsRUFBRSxVQUFVO3dCQUN6Qyw4QkFBOEIsRUFBRSxhQUFhO3dCQUM3QyxtQ0FBbUMsRUFBRSxxREFBcUQ7cUJBQzNGO29CQUNELE1BQU0sRUFBRSxDQUFDLFVBQVUsRUFBRSxPQUFPLEVBQUUsVUFBVSxDQUFDO29CQUN6QyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTs7aUJBQ2hEOzs7O2dCQTVDMEIsVUFBVTtnQkFFNUIsWUFBWTtnQkFGa0IsaUJBQWlCO2dCQUcvQyxjQUFjLHVCQThEbEIsUUFBUTs2Q0FDUixTQUFTLFNBQUMsVUFBVTs7O3VCQXBCdEIsS0FBSzt3QkFDTCxLQUFLOzhCQUVMLEtBQUs7O0lBZ0NSLG9DQUFDO0NBQUEsQUF6RUQsQ0FxQ21ELFNBQVMsR0FvQzNEO1NBcENZLDZCQUE2Qjs7O0lBQ3hDLDZDQUF5Qjs7SUFDekIsOENBQW1COzs7OztJQVNuQixxREFBeUI7Ozs7O0lBR3pCLDREQUF5RTs7Ozs7Ozs7O0FBeUIzRSxTQUFTLEtBQUssQ0FBQyxDQUFTLEVBQUUsR0FBTyxFQUFFLEdBQVM7SUFBbEIsb0JBQUEsRUFBQSxPQUFPO0lBQUUsb0JBQUEsRUFBQSxTQUFTO0lBQzFDLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN6QyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgRWxlbWVudFJlZiwgQ2hhbmdlRGV0ZWN0b3JSZWYsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBPcHRpb25hbCwgQXR0cmlidXRlIH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcclxuaW1wb3J0IHsgTWF0U2xpZGVyLCBNQVRfU0xJREVSX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSBcIkBhbmd1bGFyL21hdGVyaWFsL3NsaWRlclwiO1xyXG5pbXBvcnQgeyBGb2N1c01vbml0b3IgfSBmcm9tIFwiQGFuZ3VsYXIvY2RrL2ExMXlcIjtcclxuaW1wb3J0IHsgRGlyZWN0aW9uYWxpdHkgfSBmcm9tIFwiQGFuZ3VsYXIvY2RrL2JpZGlcIjtcclxuXHJcbi8qKiBDb3VudGVyIHVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcyBmb3IgcHJvZ3Jlc3MgYmFycy4gKi9cclxubGV0IHNsaWRlcnByb2dyZXNzYmFySWQgPSAwO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6IFwibWF0LXNsaWRlci1wcm9ncmVzcy1iYXJcIixcclxuICB0ZW1wbGF0ZVVybDogXCIuL21hdC1zbGlkZXItcHJvZ3Jlc3MtYmFyLmNvbXBvbmVudC5odG1sXCIsXHJcbiAgc3R5bGVVcmxzOiBbXCIuL21hdC1zbGlkZXItcHJvZ3Jlc3MtYmFyLmNvbXBvbmVudC5zY3NzXCJdLFxyXG4gIHByb3ZpZGVyczogW01BVF9TTElERVJfVkFMVUVfQUNDRVNTT1JdLFxyXG4gIGhvc3Q6IHtcclxuICAgIFwiKGZvY3VzKVwiOiBcIl9vbkZvY3VzKClcIixcclxuICAgIFwiKGJsdXIpXCI6IFwiX29uQmx1cigpXCIsXHJcbiAgICBcIihjbGljaylcIjogJ3RoaXNbXCJfb25DbGlja1wiXSA/IHRoaXNbXCJfb25DbGlja1wiXSgkZXZlbnQpIDogbnVsbCcsIC8vIEFuZ3VsYXIgNS82IHN1cHBvcnRcclxuICAgIFwiKG1vdXNlZG93bilcIjogJ3RoaXNbXCJfb25Nb3VzZWRvd25cIl0gPyB0aGlzW1wiX29uTW91c2Vkb3duXCJdKCRldmVudCkgOiBudWxsJywgLy8gQW5ndWxhciA3IHN1cHBvcnRcclxuICAgIFwiKGtleWRvd24pXCI6IFwiX29uS2V5ZG93bigkZXZlbnQpXCIsXHJcbiAgICBcIihrZXl1cClcIjogXCJfb25LZXl1cCgpXCIsXHJcbiAgICBcIihtb3VzZWVudGVyKVwiOiBcIl9vbk1vdXNlZW50ZXIoKVwiLFxyXG4gICAgXCIoc2xpZGUpXCI6IFwiX29uU2xpZGUoJGV2ZW50KVwiLFxyXG4gICAgXCIoc2xpZGVlbmQpXCI6IFwiX29uU2xpZGVFbmQoKVwiLFxyXG4gICAgXCIoc2xpZGVzdGFydClcIjogXCJfb25TbGlkZVN0YXJ0KCRldmVudClcIixcclxuICAgIGNsYXNzOiBcIm1hdC1zbGlkZXJcIixcclxuICAgIHJvbGU6IFwic2xpZGVyXCIsXHJcbiAgICBcIlt0YWJJbmRleF1cIjogXCJ0YWJJbmRleFwiLFxyXG4gICAgXCJbYXR0ci5hcmlhLWRpc2FibGVkXVwiOiBcImRpc2FibGVkXCIsXHJcbiAgICBcIlthdHRyLmFyaWEtdmFsdWVtYXhdXCI6IFwibWF4XCIsXHJcbiAgICBcIlthdHRyLmFyaWEtdmFsdWVtaW5dXCI6IFwibWluXCIsXHJcbiAgICBcIlthdHRyLmFyaWEtdmFsdWVub3ddXCI6IFwidmFsdWVcIixcclxuICAgIFwiW2F0dHIuYXJpYS1vcmllbnRhdGlvbl1cIjogJ3ZlcnRpY2FsID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCInLFxyXG4gICAgXCJbY2xhc3MubWF0LXNsaWRlci1kaXNhYmxlZF1cIjogXCJkaXNhYmxlZFwiLFxyXG4gICAgXCJbY2xhc3MubWF0LXNsaWRlci1oYXMtdGlja3NdXCI6IFwidGlja0ludGVydmFsXCIsXHJcbiAgICBcIltjbGFzcy5tYXQtc2xpZGVyLWhvcml6b250YWxdXCI6IFwiIXZlcnRpY2FsXCIsXHJcbiAgICBcIltjbGFzcy5tYXQtc2xpZGVyLWF4aXMtaW52ZXJ0ZWRdXCI6IFwiX2ludmVydEF4aXNcIixcclxuICAgIFwiW2NsYXNzLm1hdC1zbGlkZXItc2xpZGluZ11cIjogXCJfaXNTbGlkaW5nXCIsXHJcbiAgICBcIltjbGFzcy5tYXQtc2xpZGVyLXRodW1iLWxhYmVsLXNob3dpbmddXCI6IFwidGh1bWJMYWJlbFwiLFxyXG4gICAgXCJbY2xhc3MubWF0LXNsaWRlci12ZXJ0aWNhbF1cIjogXCJ2ZXJ0aWNhbFwiLFxyXG4gICAgXCJbY2xhc3MubWF0LXNsaWRlci1taW4tdmFsdWVdXCI6IFwiX2lzTWluVmFsdWVcIixcclxuICAgIFwiW2NsYXNzLm1hdC1zbGlkZXItaGlkZS1sYXN0LXRpY2tdXCI6IFwiZGlzYWJsZWQgfHwgX2lzTWluVmFsdWUgJiYgX3RodW1iR2FwICYmIF9pbnZlcnRBeGlzXCJcclxuICB9LFxyXG4gIGlucHV0czogW1wiZGlzYWJsZWRcIiwgXCJjb2xvclwiLCBcInRhYkluZGV4XCJdLFxyXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBNYXRTbGlkZXJQcm9ncmVzc0JhckNvbXBvbmVudCBleHRlbmRzIE1hdFNsaWRlciB7XHJcbiAgQElucHV0KCkgbW9kZSA9IFwiYnVmZmVyXCI7XHJcbiAgQElucHV0KCkgdmFsdWUgPSAwO1xyXG4gIC8qKiBCdWZmZXIgdmFsdWUgb2YgdGhlIHByb2dyZXNzIGJhci4gRGVmYXVsdHMgdG8gemVyby4gKi9cclxuICBASW5wdXQoKVxyXG4gIGdldCBidWZmZXJWYWx1ZSgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMucEJ1ZmZlclZhbHVlO1xyXG4gIH1cclxuICBzZXQgYnVmZmVyVmFsdWUodjogbnVtYmVyKSB7XHJcbiAgICB0aGlzLnBCdWZmZXJWYWx1ZSA9IGNsYW1wKHYgfHwgMCk7XHJcbiAgfVxyXG4gIHByaXZhdGUgcEJ1ZmZlclZhbHVlID0gMDtcclxuXHJcbiAgLyoqIFRoZSBpZCBvZiB0aGUgcHJvZ3Jlc3MgYmFyLiAqL1xyXG4gIHNsaWRlcnByb2dyZXNzYmFySWQgPSBgbWF0LXNsaWRlci1wcm9ncmVzcy1iYXItJHtzbGlkZXJwcm9ncmVzc2JhcklkKyt9YDtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxyXG4gICAgZm9jdXNNb25pdG9yOiBGb2N1c01vbml0b3IsXHJcbiAgICBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgICBAT3B0aW9uYWwoKSBkaXI6IERpcmVjdGlvbmFsaXR5LFxyXG4gICAgQEF0dHJpYnV0ZShcInRhYmluZGV4XCIpIHRhYkluZGV4OiBzdHJpbmdcclxuICApIHtcclxuICAgIHN1cGVyKGVsZW1lbnRSZWYsIGZvY3VzTW9uaXRvciwgY2hhbmdlRGV0ZWN0b3JSZWYsIGRpciwgdGFiSW5kZXgpO1xyXG4gICAgdGhpcy50YWJJbmRleCA9IHBhcnNlSW50KHRhYkluZGV4LCAxMCkgfHwgMDtcclxuICB9XHJcblxyXG4gIC8qKiBDU1Mgc3R5bGVzIGZvciB0aGUgdHJhY2sgZmlsbCBlbGVtZW50LiAqL1xyXG4gIGdldCBfdHJhY2tCdWZmZXJTdHlsZXMoKTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSB7XHJcbiAgICBpZiAodGhpcy5tb2RlID09PSBcImJ1ZmZlclwiKSB7XHJcbiAgICAgIGNvbnN0IGF4aXMgPSB0aGlzLnZlcnRpY2FsID8gXCJZXCIgOiBcIlhcIjtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUke2F4aXN9KDBweCkgc2NhbGUke2F4aXN9KCR7dGhpcy5wQnVmZmVyVmFsdWUgLyAxMDB9KWBcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKiBDbGFtcHMgYSB2YWx1ZSB0byBiZSBiZXR3ZWVuIHR3byBudW1iZXJzLCBieSBkZWZhdWx0IDAgYW5kIDEwMC4gKi9cclxuZnVuY3Rpb24gY2xhbXAodjogbnVtYmVyLCBtaW4gPSAwLCBtYXggPSAxMDApIHtcclxuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHYpKTtcclxufVxyXG4iXX0=