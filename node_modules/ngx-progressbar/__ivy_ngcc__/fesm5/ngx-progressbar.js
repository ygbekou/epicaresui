import { __read, __assign, __decorate, __param } from 'tslib';
import { Subject, Subscription, BehaviorSubject, combineLatest, timer, EMPTY, of } from 'rxjs';
import { filter, debounce, switchMap, tap, delay, finalize, takeUntil, map } from 'rxjs/operators';
import { InjectionToken, Optional, Inject, ɵɵdefineInjectable, ɵɵinject, Injectable, EventEmitter, Input, Output, Component, ChangeDetectionStrategy, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

function NgProgressComponent_ng_container_0_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 6);
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("box-shadow", "0 0 10px " + ctx_r2.color + ", 0 0 5px " + ctx_r2.color);
} }
function NgProgressComponent_ng_container_0_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 7);
    ɵngcc0.ɵɵelement(1, "div", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("border-top-color", ctx_r3.color)("border-left-color", ctx_r3.color);
} }
function NgProgressComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 1);
    ɵngcc0.ɵɵelementStart(2, "div", 2);
    ɵngcc0.ɵɵelementStart(3, "div", 3);
    ɵngcc0.ɵɵtemplate(4, NgProgressComponent_ng_container_0_div_4_Template, 1, 2, "div", 4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(5, NgProgressComponent_ng_container_0_div_5_Template, 2, 4, "div", 5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    var state_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("transition", "opacity " + ctx_r0.speed + "ms " + ctx_r0.ease);
    ɵngcc0.ɵɵattribute("active", state_r1.active);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵstyleProp("transform", state_r1.transform)("background-color", ctx_r0.color)("transition", state_r1.active ? "all " + ctx_r0.speed + "ms " + ctx_r0.ease : "none");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.meteor);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.spinner);
} }
var NgProgressRef = /** @class */ (function () {
    function NgProgressRef(customConfig, _onDestroyCallback) {
        var _this = this;
        this._onDestroyCallback = _onDestroyCallback;
        // Progress start source event (used to cancel finalizing delays)
        this._started = new Subject();
        // Progress start event: stream that emits only when it hasn't already started
        this.started = this._started.pipe(filter(function () { return !_this.isStarted; }));
        // Progress ended source event
        this._completed = new Subject();
        // Progress start event: stream that emits only when it has already started
        this.completed = this._completed.pipe(filter(function () { return _this.isStarted; }));
        // Stream that increments and updates the progress state
        this._trickling = new Subject();
        // Stream that combines "_trickling" and "config" streams
        this._worker = Subscription.EMPTY;
        this._state = new BehaviorSubject({ active: false, value: 0 });
        this._config = new BehaviorSubject(customConfig);
        this.state = this._state.asObservable();
        this.config = this._state.asObservable();
        this._worker = combineLatest(this._trickling, this._config).pipe(debounce(function (_a) {
            var _b = __read(_a, 2), start = _b[0], config = _b[1];
            return timer(start ? config.debounceTime : 0);
        }), switchMap(function (_a) {
            var _b = __read(_a, 2), start = _b[0], config = _b[1];
            return start ? _this.onTrickling(config) : _this.onComplete(config);
        })).subscribe();
    }
    Object.defineProperty(NgProgressRef.prototype, "currState", {
        // Get current progress state
        get: function () {
            return this._state.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgProgressRef.prototype, "isStarted", {
        // Check if progress has started
        get: function () {
            return this.currState.active;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Start the progress
     */
    NgProgressRef.prototype.start = function () {
        this._started.next();
        this._trickling.next(true);
    };
    /**
     * Complete the progress
     */
    NgProgressRef.prototype.complete = function () {
        this._trickling.next(false);
    };
    /**
     * Increment the progress
     */
    NgProgressRef.prototype.inc = function (amount) {
        var n = this.currState.value;
        if (!this.isStarted) {
            this.start();
        }
        else {
            if (typeof amount !== 'number') {
                amount = this._config.value.trickleFunc(n);
            }
            this.set(n + amount);
        }
    };
    /**
     * Set the progress
     */
    NgProgressRef.prototype.set = function (n) {
        this.setState({ value: this.clamp(n), active: true });
    };
    /**
     * Set config
     */
    NgProgressRef.prototype.setConfig = function (config) {
        this._config.next(__assign(__assign({}, this._config.value), config));
    };
    /**
     * Destroy progress reference
     */
    NgProgressRef.prototype.destroy = function () {
        this._worker.unsubscribe();
        this._trickling.complete();
        this._state.complete();
        this._config.complete();
        this._started.complete();
        this._completed.complete();
        this._onDestroyCallback();
    };
    /**
     * Set progress state
     */
    NgProgressRef.prototype.setState = function (state) {
        this._state.next(__assign(__assign({}, this.currState), state));
    };
    /**
     * Clamps a value to be between min and max
     */
    NgProgressRef.prototype.clamp = function (n) {
        return Math.max(this._config.value.min, Math.min(this._config.value.max, n));
    };
    /**
     * Keeps incrementing the progress
     */
    NgProgressRef.prototype.onTrickling = function (config) {
        var _this = this;
        if (!this.isStarted) {
            this.set(this._config.value.min);
        }
        return timer(0, config.trickleSpeed).pipe(tap(function () { return _this.inc(); }));
    };
    /**
     * Completes then resets the progress
     */
    NgProgressRef.prototype.onComplete = function (config) {
        var _this = this;
        this._completed.next();
        return !this.isStarted ? EMPTY : of({}).pipe(
        // Complete the progress
        tap(function () { return _this.setState({ value: 100 }); }), 
        // Deactivate the progress after a tiny delay
        delay(config.speed * 1.7), tap(function () { return _this.setState({ active: false }); }), 
        // Use a tiny delay before resetting
        delay(config.speed), 
        // Force the progress to reset even it got cancelled
        finalize(function () { return _this.setState({ value: 0 }); }), 
        // Cancel any of the finalizing delays if the progress has started again
        takeUntil(this._started));
    };
    return NgProgressRef;
}());

var NG_PROGRESS_CONFIG = new InjectionToken('ngProgressConfig');

var ɵ0 = function (n) {
    if (n >= 0 && n < 20)
        return 10;
    if (n >= 20 && n < 50)
        return 4;
    if (n >= 50 && n < 80)
        return 2;
    if (n >= 80 && n < 99)
        return 0.5;
    return 0;
};
var defaultConfig = {
    min: 8,
    max: 100,
    speed: 200,
    debounceTime: 0,
    trickleSpeed: 300,
    fixed: true,
    meteor: true,
    thick: false,
    spinner: true,
    ease: 'linear',
    color: '#1B95E0',
    direction: 'ltr+',
    spinnerPosition: 'right',
    trickleFunc: ɵ0
};
var NgProgress = /** @class */ (function () {
    function NgProgress(config) {
        // Store progress bar instances
        this._instances = new Map();
        this.config = config ? __assign(__assign({}, defaultConfig), config) : defaultConfig;
    }
    /**
     * Get or Create progress bar by ID
     */
    NgProgress.prototype.ref = function (id, config) {
        if (id === void 0) { id = 'root'; }
        if (this._instances.has(id)) {
            // Get ProgressRef instance
            var progressRef = this._instances.get(id);
            if (config) {
                progressRef.setConfig(__assign(__assign({}, this.config), config));
            }
            return progressRef;
        }
        else {
            // Create new ProgressRef instance
            var progressRef = new NgProgressRef(__assign(__assign({}, this.config), config), this.deleteInstance(id));
            return this._instances.set(id, progressRef).get(id);
        }
    };
    /**
     * Destroy all progress bar instances
     */
    NgProgress.prototype.destroyAll = function () {
        this._instances.forEach(function (ref) { return ref.destroy(); });
    };
    /**
     * A destroyer function for each progress bar instance
     */
    NgProgress.prototype.deleteInstance = function (id) {
        var _this = this;
        return function () {
            _this._instances.delete(id);
        };
    };
    NgProgress.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NG_PROGRESS_CONFIG,] }] }
    ]; };
    NgProgress.ɵprov = ɵɵdefineInjectable({ factory: function NgProgress_Factory() { return new NgProgress(ɵɵinject(NG_PROGRESS_CONFIG, 8)); }, token: NgProgress, providedIn: "root" });
    NgProgress = __decorate([ __param(0, Optional()), __param(0, Inject(NG_PROGRESS_CONFIG))
    ], NgProgress);
NgProgress.ɵfac = function NgProgress_Factory(t) { return new (t || NgProgress)(ɵngcc0.ɵɵinject(NG_PROGRESS_CONFIG, 8)); };
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgProgress, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NG_PROGRESS_CONFIG]
            }] }]; }, null); })();
    return NgProgress;
}());

var NgProgressComponent = /** @class */ (function () {
    function NgProgressComponent(_ngProgress) {
        this._ngProgress = _ngProgress;
        this._started = Subscription.EMPTY;
        this._completed = Subscription.EMPTY;
        /** Creates a new instance if id is not already exists */
        this.id = 'root';
        /** Initializes inputs from the global config */
        this.min = this._ngProgress.config.min;
        this.max = this._ngProgress.config.max;
        this.ease = this._ngProgress.config.ease;
        this.color = this._ngProgress.config.color;
        this.speed = this._ngProgress.config.speed;
        this.thick = this._ngProgress.config.thick;
        this.fixed = this._ngProgress.config.fixed;
        this.meteor = this._ngProgress.config.meteor;
        this.spinner = this._ngProgress.config.spinner;
        this.trickleSpeed = this._ngProgress.config.trickleSpeed;
        this.debounceTime = this._ngProgress.config.debounceTime;
        this.trickleFunc = this._ngProgress.config.trickleFunc;
        this.spinnerPosition = this._ngProgress.config.spinnerPosition;
        this.direction = this._ngProgress.config.direction;
        this.started = new EventEmitter();
        this.completed = new EventEmitter();
    }
    Object.defineProperty(NgProgressComponent.prototype, "isStarted", {
        get: function () {
            return this.progressRef.isStarted;
        },
        enumerable: true,
        configurable: true
    });
    NgProgressComponent.prototype.ngOnChanges = function () {
        if (this.progressRef instanceof NgProgressRef) {
            // Update progress bar config when inputs change
            this.progressRef.setConfig({
                max: (this.max > 0 && this.max <= 100) ? this.max : 100,
                min: (this.min < 100 && this.min >= 0) ? this.min : 0,
                speed: this.speed,
                trickleSpeed: this.trickleSpeed,
                trickleFunc: this.trickleFunc,
                debounceTime: this.debounceTime
            });
        }
    };
    NgProgressComponent.prototype.ngOnInit = function () {
        var _this = this;
        // Get progress bar service instance
        this.progressRef = this._ngProgress.ref(this.id, {
            max: this.max,
            min: this.min,
            speed: this.speed,
            trickleSpeed: this.trickleSpeed,
            debounceTime: this.debounceTime
        });
        // Subscribe to progress state
        this.state$ = this.progressRef.state.pipe(map(function (state) { return ({
            active: state.active,
            transform: "translate3d(" + state.value + "%,0,0)"
        }); }));
        // Subscribes to started and completed events on demand
        if (this.started.observers.length) {
            this._started = this.progressRef.started.subscribe(function () { return _this.started.emit(); });
        }
        if (this.completed.observers.length) {
            this._completed = this.progressRef.completed.subscribe(function () { return _this.completed.emit(); });
        }
    };
    NgProgressComponent.prototype.ngOnDestroy = function () {
        this._started.unsubscribe();
        this._completed.unsubscribe();
        if (this.progressRef instanceof NgProgressRef) {
            this.progressRef.destroy();
        }
    };
    NgProgressComponent.prototype.start = function () {
        this.progressRef.start();
    };
    NgProgressComponent.prototype.complete = function () {
        this.progressRef.complete();
    };
    NgProgressComponent.prototype.inc = function (n) {
        this.progressRef.inc(n);
    };
    NgProgressComponent.prototype.set = function (n) {
        this.progressRef.set(n);
    };
    NgProgressComponent.ctorParameters = function () { return [
        { type: NgProgress }
    ]; };
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "id", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "min", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "max", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "ease", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "color", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "speed", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "thick", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "fixed", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "meteor", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "spinner", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "trickleSpeed", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "debounceTime", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "trickleFunc", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "spinnerPosition", void 0);
    __decorate([
        Input()
    ], NgProgressComponent.prototype, "direction", void 0);
    __decorate([
        Output()
    ], NgProgressComponent.prototype, "started", void 0);
    __decorate([
        Output()
    ], NgProgressComponent.prototype, "completed", void 0);
NgProgressComponent.ɵfac = function NgProgressComponent_Factory(t) { return new (t || NgProgressComponent)(ɵngcc0.ɵɵdirectiveInject(NgProgress)); };
NgProgressComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgProgressComponent, selectors: [["ng-progress"]], hostAttrs: ["role", "progressbar"], hostVars: 4, hostBindings: function NgProgressComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("spinnerPosition", ctx.spinnerPosition)("dir", ctx.direction)("thick", ctx.thick)("fixed", ctx.fixed);
    } }, inputs: { id: "id", min: "min", max: "max", ease: "ease", color: "color", speed: "speed", thick: "thick", fixed: "fixed", meteor: "meteor", spinner: "spinner", trickleSpeed: "trickleSpeed", debounceTime: "debounceTime", trickleFunc: "trickleFunc", spinnerPosition: "spinnerPosition", direction: "direction" }, outputs: { started: "started", completed: "completed" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 3, consts: [[4, "ngIf"], [1, "ng-progress-bar"], [1, "ng-bar-placeholder"], [1, "ng-bar"], ["class", "ng-meteor", 3, "boxShadow", 4, "ngIf"], ["class", "ng-spinner", 4, "ngIf"], [1, "ng-meteor"], [1, "ng-spinner"], [1, "ng-spinner-icon"]], template: function NgProgressComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NgProgressComponent_ng_container_0_Template, 6, 11, "ng-container", 0);
        ɵngcc0.ɵɵpipe(1, "async");
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ɵngcc0.ɵɵpipeBind1(1, 1, ctx.state$));
    } }, directives: [ɵngcc1.NgIf], pipes: [ɵngcc1.AsyncPipe], styles: ["[_nghost-%COMP%]{z-index:999999;pointer-events:none}[fixed=true][_nghost-%COMP%]   .ng-progress-bar[_ngcontent-%COMP%], [fixed=true][_nghost-%COMP%]   .ng-spinner[_ngcontent-%COMP%]{position:fixed}[fixed=true][_nghost-%COMP%]   .ng-spinner[_ngcontent-%COMP%]{top:15px}[fixed=true][spinnerPosition=left][_nghost-%COMP%]   .ng-spinner[_ngcontent-%COMP%]{left:15px}[fixed=true][spinnerPosition=right][_nghost-%COMP%]   .ng-spinner[_ngcontent-%COMP%]{right:15px}[thick=true][_nghost-%COMP%]   .ng-spinner-icon[_ngcontent-%COMP%]{width:24px;height:24px;border-width:3px}[thick=true][_nghost-%COMP%]   .ng-bar-placeholder[_ngcontent-%COMP%]{height:3px!important}[dir=\"ltr+\"][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [dir=ltr-][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{-webkit-transform:rotate(3deg);transform:rotate(3deg)}[dir=\"ltr+\"][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [dir=ltr-][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{-webkit-transform:rotate(4deg);transform:rotate(4deg)}[dir=\"ltr+\"][_nghost-%COMP%]   .ng-bar[_ngcontent-%COMP%], [dir=\"rtl+\"][_nghost-%COMP%]   .ng-bar[_ngcontent-%COMP%]{margin-left:-100%}[dir=\"ltr+\"][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [dir=\"rtl+\"][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{right:0}[dir=\"ltr+\"][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [dir=rtl-][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{top:-3px}[dir=\"ltr+\"][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [dir=rtl-][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{top:-4px}[dir=\"rtl+\"][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [dir=ltr-][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{bottom:-3px}[dir=\"rtl+\"][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [dir=ltr-][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{bottom:-4px}[dir=\"rtl+\"][_nghost-%COMP%]   .ng-bar-placeholder[_ngcontent-%COMP%], [dir=ltr-][_nghost-%COMP%]   .ng-bar-placeholder[_ngcontent-%COMP%]{-webkit-transform:rotate(180deg);transform:rotate(180deg)}[dir=\"rtl+\"][_nghost-%COMP%]   .ng-spinner-icon[_ngcontent-%COMP%], [dir=ltr-][_nghost-%COMP%]   .ng-spinner-icon[_ngcontent-%COMP%]{animation-direction:reverse}[dir=\"rtl+\"][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [dir=rtl-][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{-webkit-transform:rotate(-3deg);transform:rotate(-3deg)}[dir=\"rtl+\"][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%], [dir=rtl-][thick=true][_nghost-%COMP%]   .ng-meteor[_ngcontent-%COMP%]{-webkit-transform:rotate(-4deg);transform:rotate(-4deg)}[spinnerPosition=left][_nghost-%COMP%]   .ng-spinner[_ngcontent-%COMP%]{left:10px}[spinnerPosition=right][_nghost-%COMP%]   .ng-spinner[_ngcontent-%COMP%]{right:10px}.ng-progress-bar[_ngcontent-%COMP%]{position:relative;z-index:999999;top:0;left:0;width:100%;zoom:1;opacity:0}.ng-progress-bar[active=true][_ngcontent-%COMP%]{opacity:1;-webkit-transition:none;transition:none}.ng-bar-placeholder[_ngcontent-%COMP%]{position:absolute;height:2px;width:100%}.ng-bar[_ngcontent-%COMP%]{width:100%;height:100%;-webkit-transform:translate(-100%,0,0);transform:translate(-100%,0,0)}.ng-meteor[_ngcontent-%COMP%]{display:block;position:absolute;width:100px;height:100%;opacity:1}.ng-spinner[_ngcontent-%COMP%]{position:absolute;display:block;z-index:1031;top:10px}.ng-spinner-icon[_ngcontent-%COMP%]{width:18px;height:18px;box-sizing:border-box;-webkit-animation:250ms linear infinite spinner-animation;animation:250ms linear infinite spinner-animation;border:2px solid transparent;border-radius:50%}@-webkit-keyframes spinner-animation{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spinner-animation{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}"], changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgProgressComponent, [{
        type: Component,
        args: [{
                selector: 'ng-progress',
                host: {
                    'role': 'progressbar',
                    '[attr.spinnerPosition]': 'spinnerPosition',
                    '[attr.dir]': 'direction',
                    '[attr.thick]': 'thick',
                    '[attr.fixed]': 'fixed'
                },
                template: "\n    <ng-container *ngIf=\"state$ | async; let state\">\n      <div class=\"ng-progress-bar\"\n            [attr.active]=\"state.active\"\n            [style.transition]=\"'opacity ' + speed + 'ms ' + ease\">\n        <div class=\"ng-bar-placeholder\">\n          <div class=\"ng-bar\"\n                [style.transform]=\"state.transform\"\n                [style.backgroundColor]=\"color\"\n                [style.transition]=\"state.active ? 'all ' + speed + 'ms ' + ease : 'none'\">\n            <div *ngIf=\"meteor\" class=\"ng-meteor\" [style.boxShadow]=\"'0 0 10px '+ color + ', 0 0 5px ' + color\"></div>\n          </div>\n        </div>\n        <div *ngIf=\"spinner\" class=\"ng-spinner\">\n          <div class=\"ng-spinner-icon\"\n                [style.borderTopColor]=\"color\"\n                [style.borderLeftColor]=\"color\"></div>\n        </div>\n      </div>\n    </ng-container>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{z-index:999999;pointer-events:none}:host[fixed=true] .ng-progress-bar,:host[fixed=true] .ng-spinner{position:fixed}:host[fixed=true] .ng-spinner{top:15px}:host[fixed=true][spinnerPosition=left] .ng-spinner{left:15px}:host[fixed=true][spinnerPosition=right] .ng-spinner{right:15px}:host[thick=true] .ng-spinner-icon{width:24px;height:24px;border-width:3px}:host[thick=true] .ng-bar-placeholder{height:3px!important}:host[dir=\"ltr+\"] .ng-meteor,:host[dir=ltr-] .ng-meteor{-webkit-transform:rotate(3deg);transform:rotate(3deg)}:host[dir=\"ltr+\"][thick=true] .ng-meteor,:host[dir=ltr-][thick=true] .ng-meteor{-webkit-transform:rotate(4deg);transform:rotate(4deg)}:host[dir=\"ltr+\"] .ng-bar,:host[dir=\"rtl+\"] .ng-bar{margin-left:-100%}:host[dir=\"ltr+\"] .ng-meteor,:host[dir=\"rtl+\"] .ng-meteor{right:0}:host[dir=\"ltr+\"] .ng-meteor,:host[dir=rtl-] .ng-meteor{top:-3px}:host[dir=\"ltr+\"][thick=true] .ng-meteor,:host[dir=rtl-][thick=true] .ng-meteor{top:-4px}:host[dir=\"rtl+\"] .ng-meteor,:host[dir=ltr-] .ng-meteor{bottom:-3px}:host[dir=\"rtl+\"][thick=true] .ng-meteor,:host[dir=ltr-][thick=true] .ng-meteor{bottom:-4px}:host[dir=\"rtl+\"] .ng-bar-placeholder,:host[dir=ltr-] .ng-bar-placeholder{-webkit-transform:rotate(180deg);transform:rotate(180deg)}:host[dir=\"rtl+\"] .ng-spinner-icon,:host[dir=ltr-] .ng-spinner-icon{animation-direction:reverse}:host[dir=\"rtl+\"] .ng-meteor,:host[dir=rtl-] .ng-meteor{-webkit-transform:rotate(-3deg);transform:rotate(-3deg)}:host[dir=\"rtl+\"][thick=true] .ng-meteor,:host[dir=rtl-][thick=true] .ng-meteor{-webkit-transform:rotate(-4deg);transform:rotate(-4deg)}:host[spinnerPosition=left] .ng-spinner{left:10px}:host[spinnerPosition=right] .ng-spinner{right:10px}.ng-progress-bar{position:relative;z-index:999999;top:0;left:0;width:100%;zoom:1;opacity:0}.ng-progress-bar[active=true]{opacity:1;-webkit-transition:none;transition:none}.ng-bar-placeholder{position:absolute;height:2px;width:100%}.ng-bar{width:100%;height:100%;-webkit-transform:translate(-100%,0,0);transform:translate(-100%,0,0)}.ng-meteor{display:block;position:absolute;width:100px;height:100%;opacity:1}.ng-spinner{position:absolute;display:block;z-index:1031;top:10px}.ng-spinner-icon{width:18px;height:18px;box-sizing:border-box;-webkit-animation:250ms linear infinite spinner-animation;animation:250ms linear infinite spinner-animation;border:2px solid transparent;border-radius:50%}@-webkit-keyframes spinner-animation{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spinner-animation{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}"]
            }]
    }], function () { return [{ type: NgProgress }]; }, { id: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], ease: [{
            type: Input
        }], color: [{
            type: Input
        }], speed: [{
            type: Input
        }], thick: [{
            type: Input
        }], fixed: [{
            type: Input
        }], meteor: [{
            type: Input
        }], spinner: [{
            type: Input
        }], trickleSpeed: [{
            type: Input
        }], debounceTime: [{
            type: Input
        }], trickleFunc: [{
            type: Input
        }], spinnerPosition: [{
            type: Input
        }], direction: [{
            type: Input
        }], started: [{
            type: Output
        }], completed: [{
            type: Output
        }] }); })();
    return NgProgressComponent;
}());

var NgProgressModule = /** @class */ (function () {
    function NgProgressModule() {
    }
    NgProgressModule_1 = NgProgressModule;
    NgProgressModule.withConfig = function (config) {
        return {
            ngModule: NgProgressModule_1,
            providers: [
                { provide: NG_PROGRESS_CONFIG, useValue: config }
            ]
        };
    };
    var NgProgressModule_1;
NgProgressModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgProgressModule });
NgProgressModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgProgressModule_Factory(t) { return new (t || NgProgressModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgProgressModule, { declarations: function () { return [NgProgressComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NgProgressComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgProgressModule, [{
        type: NgModule,
        args: [{
                declarations: [NgProgressComponent],
                exports: [NgProgressComponent],
                imports: [CommonModule]
            }]
    }], function () { return []; }, null); })();
    return NgProgressModule;
}());

/*
 * Public API Surface of ngx-progressbar
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NG_PROGRESS_CONFIG, NgProgress, NgProgressComponent, NgProgressModule, NgProgressRef, ɵ0 };

//# sourceMappingURL=ngx-progressbar.js.map